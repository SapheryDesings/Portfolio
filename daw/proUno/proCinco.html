<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../css/clases.css">
  
  <link rel="stylesheet" href="../../css/mediaQ.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titan+One&display=swap" rel="stylesheet">
  <title>Programación I</title>
</head>
<body>
  <header>
    <div class="navtop">
      <a href="../proUno/indiceProUno.html">Programación I</a>
      <a href="../../index.html">Principal</a>
    </div>
  </header> 
  <main class="main--Apuntes">
    <a name="5.0"></a>
    <h3 class="subTitulo_3">Introducción</h3>
    <article class="articuloApuntes">
      <p>
        Hasta ahora hemos trabajado con información que una vez que finaliza la ejecución del programa, desaparece de la memoria, ya que ha estado almacenada en la memoria principal en el tiempo que dura la ejecución del software.
      </p>
      <p>
        La solución para que los datos persistan es almacenarlos en un fichero. Cada vez que ejecutemos una aplicación que trabaja con esos datos podrá leer del fichero aquellos que sean necesarios.
      </p>
    </article>
    <a class="btnArriba" href="#top">Arriba</a>
  
    
    <a name="5.1"></a>
    <h3 class="subTitulo_3">Concepto y tipos de ficheros</h3>
    <article class="articuloApuntes">
      <p>
        Un fichero es una parte de un dispositivo no volátil a la que se le asigna un nombre y que puede contener una cantidad de datos que va a estar limitada, o por la cantidad de espacio del que disponga el dispositivo, o por las características del SO. Los dispositivos no volátiles son aquellos que no pierden la información cuando apagamos nuestro ordenador.
      </p>
      <p>
        Debido a la importancia que tiene la BCL (Base Class Library) reserva un espacio de nombres denominados System.IO, destinado a trabajar con ellos.
      </p>
      <p>
        El espacio de nombres System.IO contiene tipos que permiten leer y escribir en los archivos. Ese espacio de nombres nos proporciona compatibilidad entre archivos y directorios. <br>
        Algunas de las clases que nos proporcionan son:
      </p>
      <table>
        <tr>
          <th>Clase</th>
          <th>Descripción</th>
        </tr>
        <tr>
          <td>BinaryReader</td>
          <td>Lee tipos de datos primitivos como valores binarios</td>
        </tr>
        <tr>
          <td>BinaryWriter</td>
          <td>Escribe tipos primitivos en formato binario en una secuencia y admite la escritura de cadenas</td>
        </tr>
        <tr>
          <td>File</td>
          <td>Proporciona métodos estáticos para crear, copiar, eliminar, mover y abrir un solo archivo. Contribuye a la creación de objetos FileSream</td>
        </tr>
        <tr>
          <td>BufferedSream</td>
          <td>Almacena en un búfer los datos necesarios para las operaciones de lectura y escritura en otra secuencia. No se puede heredar esta clase</td>
        </tr>
        <tr>
          <td>FileStream</td>
          <td>Proporciona un Sream para un archivo, lo que permite operaciones de lectura y escritura sincrónica y asincrónica</td>
        </tr>
        <tr>
          <td>StreamReader</td>
          <td>Implementa un TextReader que lee los caracteres de una secuencia de bytes</td>
        </tr>
        <tr>
          <td>SteamWriter</td>
          <td>Implementa TextWriter para escribir los caracteres de una secuencia</td>
        </tr>
        <tr>
          <td>TextReader</td>
          <td>Representa un lector que puede leer una serie secuencial de caracteres</td>
        </tr>
        <tr>
          <td>TextWriter</td>
          <td>Representa un escritor que puede escribir una serie secuencial de caracteres</td>
        </tr>
      </table>
      <p>
        Los ficheros se almacenan en directorios o carpetas. Esto se hace creando una estructura jerárquica, para que esta sea finita, debe existir un directorio raíz, que contenga a todos los demás y no tenga dependencia de ningún otro.
      </p>
      <h4 class="subTitulo_4">En resumen</h4>
      <p>
        Los ficheros o archivos son una secuencia de bits, bytes, líneas o registros que se almacenan en un dispositivo de almacenamiento secundario, por lo que la información va a permanecer a pesar de que se cierre la aplicación que los utilice.
      </p>
      <p>
        Esto permite más independencia sobre la información, ya que no necesita que el programa se esté ejecutando para que la información exista.
      </p>
      <p>
        Para manipular un fichero, realizamos tres operaciones:
      </p>
      <ul>
        <li>Abrir el fichero</li>
        <li>Escribir o leer registros del fichero</li>
        <li>Cerrar el fichero</li>
      </ul>
      <p>
        Cuando trabajamos con ficheros, debemos tener en cuenta:
      </p>
      <ul>
        <li>La información es binaria</li>
        <li>Al agrupar los bits, se forman bytes o palabras</li>
        <li>Los tipos de datos van a estar formados por un conjunto de bytes o palabras</li>
        <li>Al agrupar los campos, se crean los registros de información</li>
        <li>Un fichero es un conjunto de bytes con una misma estructura</li>
        <li>Los directorios tienen la función de agrupar distintos ficheros siguiendo unas condiciones determinadas dadas por el SO o por el programador</li>
      </ul>
      <h4 class="subTitulo_4">Utilidades de los ficheros</h4>
      <ul>
        <li>Permiten organizar más fácilmente el sistema de archivos</li>
        <li>Evitan conflictos con sus nombres, ya que cada programa instala sus ficheros en directorios diferentes.Pueden tener el mismo nombre pero tendrán distinta ruta</li>
        <li>La relación entre ficheros y directorio es muy cercana, se establece entre tipos y espacio de nombres</li>
      </ul>
      <h4 class="subTitulo_4">Rutas de fichero y directorios</h4>
      <p>
        Para la identificación de este fichero, habrá que nombrar el camino que nos lleva hasta él. Este camino se denomina ruta. <br>
        Dependiendo de cómo empecemos la ruta de directorio para nombrar el archivo:
      </p>
      <ul>
        <li><strong>Ruta absoluta o completa:</strong> se indica el camino desde el comienzo. En linux se empieza por "/", Windows cada partición posee un directorio raíz, no existe un directorio ráiz común que los contenga a todos ellos.</li>
        <li><strong>Ruta relativa:</strong> se le indica el camino del directorio desde la posición actual.</li>
      </ul>
      <h4 class="subTitulo_4">Tipos de fichero</h4>
      <ul>
        <li>
          <strong>Según su acceso:</strong> según la forma de organizar la información:
          <ul>
            <li><strong>Secuencial:</strong> los registros se van almacenando en posiciones consecutivas de manera que cada vez que queramos acceder a ellos tendremos que empezar desde el primero e ir recorriéndolos de uno en uno</li>
            <li><strong>Aleatorio o directo:</strong> podemos acceder a un registro concreto indicando una posición perteneciente a un conjunto de posiciones posibles. Los registros están organizados y pueden ser léidos o escritos en cualquier orden, ya que se accede a cada uno da través de su posición. Cuando queremos realizar una operación, basta con colocar el puntero que maneja el fichero justo antes de este</li>
            <li>
              <strong>Secuencial indexado:</strong> poseen un campo clave (índice) para ser identificados. Permiten el acceso secuencial y aleatorio a un fichero de la siguiente forma: <br>
              <ol>
                <li>Primero busca de forma secuencial el campo clave o índice</li>
                <li>Una vez que lo encuentra, el acceso al fichero es directo, ya que solo tenemos que acceder a la posición indicada por el campo clave</li>
              </ol><br>
              Para que este proceso funcione, los índices se encuentran ordenados, para un acceso más rápido
            </li>
          </ul>
        </li>
        <li>
          <strong>Según su estructura:</strong>
          <ul>
            <li><strong>Ficheros de texto:</strong> formados por texto plano sin formato legible por el usuario</li>
            <li><strong>Ficheros binarios:</strong> los datos se almacenan de forma binaria y de se guardan de la misma forma. Los datos se encriptan en ceros y unos, así se hace mucho más eficiente su almacenamiento.</li>
          </ul> 
        </li>
      </ul>
    </article>
    <a class="btnArriba" href="#top">Arriba</a>
  
  
    <a name="5.2"></a>
    <h3 class="subTitulo_3">Diseño y modulación de las operaciones sobre ficheros</h3>
    <article class="articuloApuntes">
      <h4 class="subTitulo_4">Fundamentos de los flujos</h4>
      <p>
        Los flujos (steam) de datos son las estructuras o pasarelas que tenemos para acceder a los datos de un fichero, de una forma consistente y fiable, desde un código fuente en cualquier lenguaje de programación.
      </p>
      <p>
        La clase Steam nos permite abstraer de una secuencia de bytes como, un archivo, un dispositivo de entrada/salida, una canalización de comunicación entre procesos o un socket.
      </p>
      <p>
        La clase FileStream deriva de la clase Steam y nos proporciona los siguientes métodos:
        <ul>
          <li>FileSteam (string nombre, FileMode modo)</li>
          <li>FileStream (string nombre, FileMode modo, FileAccess acceso)</li>
        </ul>
      </p>
      <p>
        El primer método abre un flujo de entrada y salida que se vincula al fichero especificado en el nombre, mientras que el segundo método realiza lo mismo y añade el tipo de acceso: lectura, escritura o lectura/escritura.
      </p>
      <p>
        El parámetro nombre es una cadena de caracteres que indica la ruta donde está guardado o donde se guardará el fichero. <br>
        Puede escribirse:
        <ul>
          <li>c:\\users\\AppData\\file.txt</li>
          <li>@c:\users\AppData\file.txt</li>
        </ul>
      </p>
      <p>
        La ventaja de utilizar la @ es que las secuencias de escape no se procesan. 
      </p>
      <p>
        FileMode nos indica cómo se debe abrir un archivo. Los campos toman los siguientes valores:
      </p>
      <table>
        <tr>
          <td>CreateNew</td>
          <td>Crea un nuevo fichero. Si existe, lanzará un error</td>
        </tr>
        <tr>
          <td>Truncate</td>
          <td>Abre un fichero existente. El fichero será truncado a cero bytes de longitud</td>
        </tr>
        <tr>
          <td>Create</td>
          <td>Crea un nuevo fichero. Si el fichero existe, será sobreescrito</td>
        </tr>
        <tr>
          <td>Open</td>
          <td>Abre un fichero existente. Si no existe, lanzará un error</td>
        </tr>
        <tr>
          <td>OpenOrCreate</td>
          <td>Abre un fichero si existe; si no, crea un fichero nuevo</td>
        </tr>
        <tr>
          <td>Append</td>
          <td>Abre un fichero para añadir datos al final del mismo si existe o crea un fichero nuevo si no existe</td>
        </tr>
      </table>
      <p>El parámetro acceso puede tomar los siguientes valores:</p>
      <table>
        <tr>
          <td>Read</td>
          <td>Permite acceder al fichero para realizar operaciones de lectura</td>
        </tr>
        <tr>
          <td>ReadWrite</td>
          <td>Permite acceder al fichero para realizar operaciones de lectura y escritura</td>
        </tr>
        <tr>
          <td>Write</td>
          <td>Permite acceder al fichero para realizar operaciones de escritura</td>
        </tr>
      </table>
      <p>
        En el flujo de entrada de datos (lectura), solo podemos realizar la operación de lectura, existe una comunicación unilateral desde el fichero al programa.
      </p>
      <p>
        En el flujo de salida (escritura) también es unidireccional.
      </p>
      <p>
        El el flujo o stream de entrada/salida es cuando podemos tanto leer como escribir. Este tipo lo vamos a definir al iniciar el trabajo con ficheros, y no se podrá cambiar una vez abierto.
      </p>
    </article>
    <article class="articuloApuntes">
      <h4 class="subTitulo_4">Clases de flujos</h4>
      <p>
        Utilizaremos las clases pertenecientes a los dos tipos de ficheros: binarios y de texto. Se pueden distinguir dos tipos de flujos:
      </p>
      <ul>
        <li><strong>Flujos base:</strong> Son aquellos que operan más a nivel máquina, como, porción de memoria, espacio de disco o conexión de red</li>
        <li><strong>Flujos intermedios:</strong> Trabajan por encima de los anteriores. Se pueden combinar con el flujo base de manera que este pueda verse beneficiado por todas las funcionalidades que ofrezca el flujo base</li>
        <li>El <strong>flujo intermedio</strong> procesa la información, mientras que la base realiza la función de envío de bytes de un lugar a otro</li>
      </ul>
    </article>
    <a class="btnArriba" href="#top">Arriba</a>
  
  
    <a name="5.3"></a>
    <h3 class="subTitulo_3">Operaciones sobre ficheros secuenciales</h3>
    <article class="articuloApuntes">
      <article class="articuloApuntes">
        <h4 class="subTitulo_4">Apertura</h4>
        <p>
          Lo primero siempre es abrir el fichero para que la operación que vayamos a realizar sobre él. Estamos relacionando un objeto de nuestro programa con un archivo. <br>
          Modos en los que se puede abrir un fichero:
        </p>
        <ul>
          <li><strong>Open:</strong> Abrimos un fichero, que desencadena una excepción si el fichero no existe (FileNotFoundException)</li>
          <li><strong>Create:</strong> Creamos un nuevo fichero. Si ya existe se sobrescribirá, equivalente a utilizar CreateNew si no existe el archivo, y Truncate en caso contrario</li>
          <li><strong>CreateNew:</strong> Creamos un nuevo fichero, si ya existe lanzará una excepción (IOExcption)</li>
          <li><strong>Truncate:</strong> Abrimos un archvios existenete, se debe truncar su tamaño a cero bytes. Al intentar leer un archivo en este modo se producirá una excepción (ArgumentException)</li>
          <li><strong>OpenOrCreate:</strong> Abre un archivo si ya existe, si no se crea uno nuevo</li>
          <li><strong>Append:</strong> Abre el archivo si existe y realiza una búsqueda hasta el final, si no existe crea uno nuevo</li>
        </ul>
      </article>
      <article class="articuloApuntes">
        <h4 class="subTitulo_4">Lectura/escritura</h4>
        <p>
          Al leer o escribir tenemos que prestar atención tanto al fin de fichero en ficheros secuenciales como a la posición del puntero en ficheros aleatorios.
        </p>
        <p>
          Las operaciones E/S se pueden hacer para ficheros secuenciales o para ficheros aleatorios.
        </p>
        <h4 class="subTitulo_4">Lectura secuencial</h4>
        <p>
          <pre>
            <code>
              // PSEUDOCÓDIGO 
              // Declaración de la variable del fichero 
                fichero f1; 
              // Abrimos el fichero para leerlo 
                f1.abrir(lectura); 
                Mientras no final de fichero Hacer 
                  f1.leer(registro); 
                  operaciones con registro leído; 
                FinMientras 
              // Cerramos el fichero 
                f1.cerrar(); 
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Escritura secuencial</h4>
        <p>
          <pre>
            <code>
              // PSEUDOCÓDIGO 
              // Declaración de la variable del fichero 
                fichero f1; 
              // Abrimos el fichero para leerlo 
                f1.abrir(escritura); 
                Mientras existan datos a escribir 
                  f1.escribir(registro); 
                FinMientras 
              // Cerramos el fichero 
                f1.cerrar();
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Lectura aleatoria</h4>
        <p>
          <pre>
            <code>
              // PSEUDOCÓDIGO 
              // Declaración de la variable del fichero 
                fichero f1; 
              // Abrimos el fichero para leerlo
                f1.abrir(lectura); 
                Situar el puntero del fichero justo antes del 
                registro requerido 
                  f1.leer(registro); 
                Otras operaciones con registro leído; 
              // Cerramos el fichero 
                f1.cerrar(); 
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Escritura aleatoria</h4>
        <p>
          <pre>
            <code>
              // Declaración de la variable del fichero 
                fichero f1; 
              // Abrimos el fichero para leerlo 
                f1.abrir(escritura); 
                Mientras se deseen escribir datos Hacer 
                  Posicionar el puntero del fichero en la posición deseada 
                    f1.escribir(registro); 
                  otras operaciones con registro leído; 
                finMientras 
              //Cerramos el fichero 
                f1.cerrar(); 
            </code>
          </pre>
        </p>
      </article>
      <article class="articuloApuntes">
        <h4 class="subTitulo_4">Cierre</h4>
        <p>
          Cuando cerramos el fichero, este queda liberado y termina el proceso de almacenamiento de información.
        </p>
      </article>
    </article>
    <article class="articuloApuntes">
      <h4 class="subTitulo_4">Clase FileSteam</h4>
        <h4 class="subTitulo_4">Ficheros de texto</h4>
        <p>
          Los datos pueden ser escritos o leídos de un fichero utilizando los flujos de las clases StreamWriter y SteamReader:
        </p>
        <ul>
          <li>StreamReader implementa un TextReader que lee los caracteres de una secuencia de bytes</li>
          <li>StreamWriter implementa un TextWriter para escribir los caracteres de una secuencia</li>
        </ul>
        <h4 class="subTitulo_4">Lectura de un fichero de texto</h4>
        <p>
          <pre>
            <code>
              using System.IO; // Importación de la clase System.IO 
              // Creamos la variable fichero con la clase FileStream pasando la ruta 
              del fichero, el modo de apertura (Open) y cómo vamos a acceder a él 
              (lectura) 
                FileStream fichero = new FileStream(“C:/fichero/ejercicio1.txt”, File- 
                Mode.Open, FileAccess.Read); 
              // Abrimos el flujo de lectura 
              // Proporciona una vista genérica de una secuencia de bytes 
                StreamReader fs = new StreamReader(fichero); 
                string linea = “”; 
                while ((linea = fs.ReadLine()) != null) // Mientras no lleguemos a final 
                de fichero 
                  Console.WriteLine(linea); //sacamos por pantalla lo 
                  que contenga el fichero 
                fs.Close(); // cerramos el flujo 
                fichero.Close(); // cerramos el fichero 
                } 
              } 
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Escritura de un fichero</h4>
        <p>
          <pre>
            <code>
              using System.IO; // Importación de la clase System.IO 
              // Creamos la variable fichero con la clase FileStream pasando la ruta 
              del fichero, el modo de apertura (en este caso, vamos a añadir datos al 
              final del fichero -> Append) y cómo vamos a acceder a él (escritura) 
                FileStream fichero = new FileStream(“C:/fichero/ejercicio1.txt”, File- 
                Mode.Append, FileAccess.Write); 
              // abrimos el flujo de escritura 
                StreamWriter fs = new StreamWriter(fichero); >
              //pedimos al usuario una cadena de texto la escribiremos en el fichero 
                Console.WriteLine(“Introduce una frase: “); 
                string frase = Console.ReadLine(); 
                fs.WriteLine(frase); 
              // cerramos el flujo y el fichero 
                fs.Close(); 
                fichero.Close(); 
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Ficheros binarios</h4>
        <p>
          Normalmente trabjamos con ficheros de texto, pero también nos encontramos con información organizada como una secuencia de bytes, como ficheros de imágenes, de sonido, de video, etc...
        </p>
        <p>
          Comenzamos por utilizar la clase FileStream, para acceder a un byte o a bloques de byte. Esto nos proporciona un método para el acceso:
        </p>
        <p>
          <strong>Read(Byte[], int offset, int count)</strong> lee un bloque de bytes de la secuencia y escribe los datos en un búffer dado. <br>
          Los parámetros:
        </p>
        <ul>
          <li><strong>array Byte[]:</strong> contiene la matriz de bytes con los valores de offset y reemplazados por leídos desde el origen actual</li>
          <li><strong>offset:</strong> se colocarán los bytes leídos</li>
          <li><strong>count:</strong> el número máximo de bytes que se deben leer</li>
        </ul>
        <p>
          <pre>
            <code>
                byte[] buffer = new byte[fichero.Length]; 
              // creamos un array unidimensional con la cantidad de bytes que se 
              compone el fichero 
                fichero.Read(buffer, 0, buffer.Length); 
              // Vamos a leer el buffer donde todavía no hemos consumido ningún byte 
              y el número máximo que vamos a leer es lo que contiene el buffer 
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Ejemplo de lectura en ficheros binarios</h4>
        <p>
          <pre>
            <code>
                using System.IO; 
              // Vamos a trabajar con un fichero imagen, de tal forma que lo abriremos 
              de modo lectura 
                FileStream fichero = new FileStream(“C:/fichero/pelota.jpg”, FileMode. 
                Open, FileAccess.Read); 
              // Creamos un buffer de tipo byte para poder trabajar con los datos del 
              fichero 
                Byte [] buffer = new byte[fichero.Length]; //un entero de 8 bits sin 
              signo. 
              // Abrimos el fichero para la lectura y vamos a ir consumiendo todos 
              los bytes del fichero y mostrándolos por pantalla 
                fichero.Read(buffer, 0, buffer.Length); 
                for (int i = 0; i < buffer.Length; i++) 
                  { 
                    Console.WriteLine(buffer[i]); 
                  } 
              //fichero.Close(); 
            </code>
          </pre>
        </p>
        <h4 class="subTitulo_4">Ejemplo de escritura en ficheros binarios</h4>
        <p>
          <pre>
            <code>
                using System.IO; 
              // Vamos a trabajar con un fichero imagen, de tal forma que lo abriremos 
              de modo lectura 
                FileStream fichero = new FileStream(“C:/fichero/pelota.jpg”, FileMode. 
                Open, FileAccess.Read); 
              // Creamos un buffer de tipo byte para poder trabajar con los datos del 
              fichero 
                Byte [] buffer = new byte[fichero.Length]; //un entero de 8 bits sin 
                signo. 
              // Abrimos el fichero para la lectura y vamos a ir consumiendo todos 
              los bytes del fichero y mostrándolos por pantalla 
                fichero.Read(buffer, 0, buffer.Length); 
                for (int i = 0; i < buffer.Length; i++) 
                  { 
                    Console.WriteLine(buffer[i]);
                  } 
              //fichero.Close(); 
            </code>
          </pre>
        </p>
    </article>
    <a class="btnArriba" href="#top">Arriba</a>
  
  
    <a name="5.4"></a>
    <h3 class="subTitulo_3">Control de excepciones</h3>
    <article class="articuloApuntes">
      <p>
        Hasta ahora, el problema es que no hemos comprobado si ese fichero realmente existe o no, lo que puede suponer que nuestro programa falle en caso de que el fichero no se encuentre donde esperamos. <br>
        Una primera solución es usar el método exists para comprobar si está, antes de abrirlo.
      </p>
      <ul>
        <li>
          <strong>Exists(string path):</strong> le pasamos la ruta del fichero y devolverá un booleano. Si no existe, devolverá un false. Si la ruta no existe o es incorrecta, también devolverá un false.
          <p>
            <pre>
              <code>
                using System.IO; 
                  if (File.Exists(@”D:\myfile.txt”)) { 
                    Console.WriteLine(“El fichero existe...”); 
                  } else { 
                    Console.WriteLine(“El fichero no existe en el directorio D…”); 
                  } 
              </code>
            </pre>
          </p>
        </li>
        <li>
          <strong>Try/catch:</strong> el bloque try contiene el código protegido que puede producir la excepción. <br>
          Los mensajes de error y acciones para corregir el error estarán en el bloque catch.
          <p>
            <pre>
              <code>
                using System.IO;

                string linea; 
                    try 
                    { 
                      FileStream fichero = new FileStream(“C:/fichero/ejercicio1. 
                      txt”, FileMode.Open, FileAccess.Read); 
                      StreamReader fs = new StreamReader(fichero); 
                      if ((linea= fs.ReadLine())!= null) 
                        Console.WriteLine(linea); 
                      fs.Close() 
                      fichero.Close(); 
                    } 
                    catch (Exception exp) 
                    { 
                  Console.WriteLine(“Ha habido un error: {0}”, exp.Message); 
                } 
              </code>
            </pre>
          </p>
        </li>
      </ul>
    </article>
    <a class="btnArriba" href="#top">Arriba</a>
  </main>
</body>
</html>