<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../css/clases.css">
  <link rel="stylesheet" href="../../css/mediaQ.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Smooch&family=Titan+One&display=swap" rel="stylesheet">
  <title>Entorno de Desarrollo</title>
</head>
    <body>
        <header>
            <div class="navtop">
                <a href="../dAw.html">Entorno de Desarrollo</a>
                <a href="../../index.html">Principal</a>
            </div>
        </header>
        <div class="contenedorApuntes">
            <h2 class="tituloTema" id="subUno">Tema 4. - Documentación y optimización</h2>
            <p>Refactorización y porqué es necesario refactorizar. Trataremos el control de versiones y para qué se utiliza en la creacción de proyectos de software. Usaremos herramientas cliente y servidor y aprenderemos a documentar las clases Java usando Javadoc.</p>
            <!--*********************************************************************-->
            <h3 class="subTitulo">4.1.- Refactorización. Concepto. Limitaciones. Patrones de refacción más usuales</h3>
            <div class="nota">La refactorización nos va a permitir optimizar un código que se ha escrito previamente, realizando cambios en la escritura interna sin que afecten al comportamiento final del producto.</div>
            <p>La refactorización tiene como objetivo limpiar el código para que se entienda mejor y se pueda modificar de forma más fácil, lo que nos va a permitir una mejor lectura y compresión de lo que se realiza. Esta modificación no alterará su ejecución ni los resultados.</p>
            <h4 class="apartado">4.1.1.- Cuándo refactorizar. Bad smells</h4>
            <p>La refactorización la deberemos ir haciendo a medida que desarrollamos el software. Mario G. Piattini y Félix Óscar García analizaron los síntomas que indican la necesidad de refactorizar. Los <b>bad smells</b> (malos olores), pequeños indicios que indican que el sistema no funciona como es debido. Los síntomas:</p>
            <ul>
                <li><b>Código duplicado:</b> Esta será la principal razón para realizar la refactorización. Si encontramos algún código repetido, deberemos unificarlo.</li>
                <li><b>Métodos muy largos:</b> Los métodos largos normalmente pueden estar compuestos de métodos más pequeños, por los que deberemos dividirlos para que, además, puedan reutilizarse.</li>
                <li><b>Clases muy grandes:</b> Si una clase es grande, tendrá muchas responsabilidades al tener demasiados métodos y atributos. Por ello, deberemos crear clases más pequeñas y que estén bien delimitadas.</li>
                <li><b>Lista de parámetros extensa:</b> Las funciones deben tener el mínimo de parámetros posible o, del contrario, tendremos un problema de encapsulación de datos. Si un método requiere de muchos parámetros, deberemos crear una clase objeto con esa cantidad de datos.</li>
                <li><b>Cambio divergente:</b> Una clase se puede modificar por diferentes motivos. Estos no tienen por qué estar relacionados y cabe la posibilidad de poder eliminar o dividir dicha clase en el caso, de que esté realizando demasiadas tareas.</li>
                <li><b>Cirugía a tiro pistola:</b> Cambios adicionales realizados después de modificar una clase para compatibilizar el cambio.</li>
                <li><b>Envidia de funcionalidad:</b> Ocurre cuando un método usa más elementos de otra clase que de la suya propia. Se resolverá pasando ese método a la clase que usa más.</li>
                <li><b>Clase de solo datos:</b> Clase que solo tiene atributos y métodos de acceso. No debería ser lo habitual.</li>
                <li><b>Legado rechazado:</b> Subclases que usan características de superclase, lo que puede inducir a un error en la jerarquía de clases.</li>
            </ul>
            <p>El proceso de refactorización posee algunas ventajas, como la sencillez de mantenimiento en el diseño del sistema y el incremento de la facilidad en la lectura y en el código fuente.</p>
            <p>Las bases de datos y las interfaces son áreas conflictivas para la refactorización. El cambio de base de datos tendría como consecuencia la migración de la estructura y de los datos.</p>
            <h4 class="apartado">4.1.2.- Refactorización en Eclipse</h4>
            <p>Con el IDE Eclipse, podemos refactorizar nuestro código.</p>
            <h4 class="apartado">Métodos y herramientas de refactorización</h4>
            <p>Mediante el uso de distintas herramientas plantearemos elementos para refactorizar y estas nos mostrarán las posibles soluciones, en las que podremos observar el resultado antes y después de la refactorización. También se les llama <b>patrones de refactorización o catálogos de refactorización</b>.</p>
            <p>Los elementos más comunes:</p>
            <ul>
                <li><b>Rename:</b> Cambia el nombre de cualquier identificador de Java. Es de las opciones más utilizadas y, una vez ejecutada, se modifican las referencias a ese identificador.</li>
                <li><b>Move:</b> Se mueve la clase de un paquete a otro, se moverá el archivo .java y se cambiarán todas las referencias.</li>
                <li><b>Extract Interface:</b> Nos va a permitir escoger los métodos de una clase para crear una interface. Una interfaz es una plantilla que define los métodos, pero no los desarrolla. Serán las clases de la interfaz la encargada de desarrollarlos.</li>
                <li><b>Extract Superclass:</b> Permite extraer una superclase. Si ya utilizaba una, la extraída será la nueva superclase. Se podrán seleccionar los métodos y atributos que van a formar parte de la nueva superclase.</li>
                <li><b>Pull Up:</b> Permite pasar un método de una subclase (o clase hija) a una superclase.</li>
                <li><b>Pull Down:</b> Permite pasar un método de una superclase a una clase hija o subclase.</li>
                <li><b>Extract Constant:</b> Convierte en una constante un número o una cadena. Se mostrará el estado antes y después de refactorizar. El objetivo es modificar el valor del literal en un único lugar.</li>
                <li><b>Extract Local Variable:</b> Se asigna una expresión a una variable local. La misma expresión a otro método no se modifica.</li>
                <li><b>Convert Local Variable to Field:</b> Convierte una variable local en un atributo privado de la clase. Tras la refactorización, todos los usos de la variable local se sustituyen por el atributo.</li>
                <li><b>Extract Method:</b> Convierte un bloque de código en un método. No debe llevar llaves abiertas. Este patrón es muy útil cuandodetectamos bad smells en métodos muy largos o en bloques de código que se repiten.</li>
                <li><b>Change Method Signatura:</b> Permite cambiar la firma de un método, el nombre y los parámetros que tiene.</li>
                <li><b>Inline:</b> Nos ajusta una referencia a una variable o método con la línea en la que se utiliza pra conseguir así una única línea de código.</li>
                <li><b>Member Type to Top Level:</b> Permite convertir una clase anidada en una clase de nivel superior con su propio archivo de Java.</li>
                <li><b>Convert Anonymous Class to Nested:</b> Permite convertir una clse anónima a una clase anidada de la clase que la contiene. Una clase anónima se caracteriza por:
                <ul>
                    <li>Utilizar la palabra <i>new</i> seguida de la definición entre llaves</li>
                    <li>Usar la palabra <i>new</i> seguida del nombre de la clase que hereda (sin extends) y la definición de la clase entre llaves</li>
                    <li>Utilizar la palabra <i>new</i> seguida del nombre de la interfaz (sin implements) y la definición de la clase anónima entre llaves</li>
                </ul>
                </li>
            </ul>
            <p>Los aspectos más importantes:</p>
            <ul>
                <li>Se reestructura el código sin que haya cambios significativos en él</li>
                <li>Los IDE (como Eclipse) soportan la refactorización. El IDE conoce las relaciones entre los métodos y las clases, permitiendo hacer cambios</li>
                <li>Antes de realizar una refactorización, hay que definir correctamente los casos de prueba</li>
            </ul>
            <h4 class="apartado">4.1.3.- Refactorización y pruebas</h4>
            <p>Para poder realizar la factorización, es muy importante contar con una buena colección de casos de prueba que nos validen nuestro sistema:</p>
            <ul>
                <li>Es recomendable que sean casos de prueba automáticos</li>
                <li>Reportar los casos de fallo y errores que se encuentren</li>
                <li>Deben poder ser ejecutados de forma independiente</li>
            </ul>
            <p>Lo primero es ejecutar las pruebas para comprobar que despuén de refactorizar el sistema no haya cambiado y tengamos los mismos resultados. Después habria que analizar los cambios que se quieren aplicar y aplicarlos.</p>
            <p>Hay que destacar que optimizar el código no es refactorizar. Ambos modifican el código sin cambiar su funcionalidad, pero optimizar suele implicar introducir dificultad al código.</p>
            <h4 class="apartado">Importancia de las pruebas a la hora de refactorizar</h4>
            <p>Las pruebas unitarias juegan un papel muy importante para el desarrollo del software.</p> 
            <ul>
                <li>Nos previenen de las pruebas de regresión (recordemos que son pruebas que consisten en volver sobre el código cuando se hayan realizado cambios). Unas pruebas robustas en los primeros estados nos ayudan a reducir el tiempo en detección de errores</li>
                <li>Facilitan refactorizar. Las pruebas unitarias nos dan seguridad suficiente para poder refactorizar y eliminar el riesgo de errores en el código</li>
                <li>Mejoran cómo está diseñada la implementación. Si el código es complejo de probar, indica que hay que refactorizar.</li>
            </ul>
            <h4 class="apartado">Ventajas de refactorizar</h4>
            <ul>
                <li>Facilita la comprensión de nuestro código, sobre todo a aquellos programadores que se incorporaron al proceso posteriormente. Si el código fuente es complejo, su lectura reduce la productividad en el análisis de este</li>
                <li>Favorece la detección de errores debido a que es más fácil de compredender y mejorar su robustez</li>
                <li>Provoca mayor rapidez en la programación</li>
                <li>Al reducir la complejidad del código, la calidad se ve incrementada durante el proceso</li>
            </ul>
            <p>Las zonas más conflictivas son las interfaces y las bases de datos:</p>
            <ul>
                <li>El aplicativo suelen estar fuertemente cohesionado con el sitema de la base de datos, por lo que una migración de esta última implica cambios estructurales y de datos</li>
                <li>El cambio de interfaz no tiene que conllevar problemas siempre y cuando se tenga acceso al código fuente. Si no, la refactorización sería problemática</li>
            </ul>
            <h4 class="apartado">4.1.4.- Patrones de diseño</h4>
            <p>Un patrón de es una solución que se puede replicar en distintos desarrollos de software.</p>
            <p>Estos patrones explican todos los problemas que se encuentran en el diseño y se debate cuál es la mejor solución.</p>
            <p>Podemos identificar las clases del diseño, cómo interactúan entre ellas y la distribución de la carga de trabajo. La estructura de un patrón:</p>
            <ul>
                <li>Nombre: descripción resumida del problema y las posibles soluciones.</li>
                <li>El problema: describimos el problema detalladamente teniendo en cuenta:
                    <ul>
                        <li>Los requisitos a la hora de hacer el aplicativo</li>
                        <li>Las restricciones</li>
                        <li>Qué tipo de propiedades y características debe tener la solución</li>
                    </ul>
                </li>
                <li>La solución: no describe una solución implementada como tal, sino que esuna plantilla que rellenar en situaciones concretas. Nos proporciona una solución abstracta y general.</li>
                <li>Consecuencias: ventajas e inconvenientes.</li>
            </ul>
            <p>Tipos de patrones:</p>
            <ul>
                <li><b>Patrones estructurales:</b> nos detallan cómo se van a relacionar unos objetos con otros. Por ejemplo, el patrón <i>adapter</i> nos permite comunicar dos clases con interfaces diferentes a través de un objeto intermedio</li>
                <li><b>Patrones de comportamiento:</b>  nos permiten detallar las responsabilidades entre los objetos. Un ejemplo sería el patrón <i>iterator</i> nos permite movernos por elementos de forma secuencial sin necesidad de entrar en su implementación.</li>
                <li><b>Patrones creacionales:</b> ayudan a la creación de nuevos objetos sin necesidad de entrar en la implementación del resto del aplicativo, como es el caso del patrón <i>singleton</i>, que delimita una a una el número de las instancias de una clase y concede un acceso global a todo nuestro sistema</li>
            </ul>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subDos">4.2.- Control de versiones. Estructura de las herramientas de control de versiones</h3>
            <p>El control de versiones implica la cantidad de poder recordar todos los cambios que se han realizado tanto en la estructura de directoreios como en el contenido de los archivos. Muy <b>útil para recuperar carpetas, archivos</b> o algún proyecto en un momento dado del desarrollo. Es necesario sber qué cambios se hacen, quién los hace y cuándo se realizan.</p>
            <p><b>Términos útiles</b> del control de versiones:</p>
            <ul>
                <li><b>Repositorio:</b> Lugar donde se almacenan los datos y los cambios realizados</li>
                <li><b>Revisión o versión:</b> Una revisión es una versión concreta de los datos almacenados. La última versión se identifica como la cabeza o <b>HEAD</b></li>
                <li><B>Etiquetar o rotular (tag):</B> Las etiquetas se crean para localizar o recuperar en cualquer momento una versión concreta del desarrollo</li>
                <li><b>Tronco (trunk):</b> Línea principal del desarrollo del proyecto</li>
                <li><b>Rama o ramificar (branch):</b> Copias de carpetas, archivos o proyectos. Se pueden crear ramas para la creación de nuevas funcionalidades o comprobación de errores</li>
                <li><b>Desplegar (checkout):</b> Copia del proyecto, archivos y carpetas en el repositorio del equipo local</li>
                <li><b>Confirmar (commit o check-in):</b> Se realiza cuando se confirman los cambios realizados en el local para integrarlos al repositorio</li>
                <li><b>Exportación (export):</b> Es similar al <i>checkout</i>, pero no se vincula la copia con el repositorio</li>
                <li><b>Importación (import):</b> Subida de carpetas y archivos al repositorio</li>
                <li><b>Actualizar (update):</b> Se realiza cuando se desea integrar los cambios realizados en el repositrorio de la copia del trabajo local</li>
                <li><b>Fusión (merge):</b> Se unen combios realizados sobre uno o varios archivos en una única revisión. Se suele realizar cuando existen varias ramas y es necesario unir los cambios realizados</li>
                <li><b>Conflicto:</b> Suele ocurrir cuando un usuario hace un checkout de un archivo y otro usuario no actualiza y realiza cambios sobre el mismo archivo. Cuando envía los cambios realizados, existe un conflicto entre ambos archivos, por lo que se deberán realizar los cambios o elegir uno de ellos</li>
                <li><b>Resolver conflicto:</b> Actuación del usuario para atender varios conflictos</li>
            </ul>
            <p>Para empezar habrá que crear primero una copia local con checkout, realizar las modificaciones y por último, subir las modificaciones con commit. Si ya está vinculada la copia, habrá que hacer update para que se haga sobre la última versión.</p>
            <h4 class="apartado">4.2.1.- Repositorio</h4>
            <p>Es fundamental el uso de una herramienta multiplataforma de código abierto que garantice el control de versiones. Usará una base de datos central llamada repositorio que contendrá archivos cuyas versiones e historias son controladas. Este repositorio actuará como servidor de archivos y recordará cada cambio realizado.</p>
            <p>Es especialmente imortante cuando un proyecto lo realizan varias personas, será básico llevar un control y un orden. Tendrá que verse como un árbol con su tronco <b>(trunk)</b>, que será la línea principal; sus ramas <b>(branches)</b>, las cuales añaden nuevas funciones o corrigen errores; y sus etiquetas <b>(tags)</b>, que marcan situaciones importantes o versiones acabadas.</p>
            <p>La estructura:</p>
            <ul>
                <li><b>Trunk:</b> se guardan las carpetas del proyecto. Aquí estará la versión básica, la línea principal</li>
                <li><b>Tags:</b> copia del proyecto, carpeta o archivo para obtener una versión que no se modifique. Serán copias del tronco y son útiles para crear versiones ya finalizadas</li>
                <li><b>Branches:</b> desarrolla versiones que serán publicadas. Es una copia del tronco que será modificada para conseguir un producto final distinto al original. Serán modificaciones de versiones cerradas</li>
            </ul>
            <h4 class="apartado">4.2.2.- Tipos de herramientas de control de versiones</h4>
            <ul>
                <li><b>GIT:</b> es una herramienta de código libre que está diseñada tanto para pequeños proyecto como para proyectos de gran envergadura. <br>
                <b>Ramificación y fusión:</b> una de las características que distingue a este control de versiones es su modelo de ramificación. GIT te permite trabajar múltiples ramas que pueden ser independientes entre sí y:
                    <ul>
                        <li>Hacer cambios de contexto sin conflictos. Podemos crear una rama para probar un determinado código. Podemos volver a donde bifurcamos esa rama y, si funciona, parchear.</li>
                        <li>Establecer líneas de código que se basan en roles. Podemos tener una rama donde solamente ese código irá a producción y otra rama donde se realizarán pruebas.</li>
                        <li>Realizar una división del trabajo basada en funciones. Cada programador estará trabajando en una funcionalidad del aplicativo. Una vez finalizada, se eliminará esta rama y se fusionará al proyecto principal.</li>
                    </ul>
                </li>
                <li>Subversión en Eclipse</li>
            </ul>
            <h4 class="apartado">Operaciones con SVN Eclipse</h4>
            <p>A la hora de realizar las operaciones con Eclipse, veremos que podremos realizar las mismas operaciones que con cualquier otro cliente.</p>
            <p>Si queremos obtener una <b>copia</b> del trabajo, pulsaremos sobre <b>Check Out</b>, almacenará la copia en la carpeta actual. <b>Check Out As</b>, la almacenará en la carpeta que elijamos. El historial de revisiones pulsaremos sobre <b>Show History</b>.</p>
            <p>En Java si se realiza algún cambio, aparecerá un símbolo ">" en los elementos asociados.</p>
            <p>Para poder ver los cambios, accederemos a la pestaña <b>Synchronize</b> de la barra de botones o también desde la perspectiva <b>Team Synchronizing</b>.</p>
            <p>Podremos hacer update, validar o ver los conflictos. Si hay <b>cambios salientes</b>, aparece una flecha negra hacia fuera; si aparece el signo "+" es que el archivo es nuevo. Lo que habría que hacer es validar este archivo.</p>
            <h4 class="apartado">Solución de conflictos</h4>
            <p>Un conflicto se producirá cuando dos usuarios modifiquen el mismo archivo del repositorio y las mismas líneas del archivo. Uno confirmará los cambios y el otro lo confirma a continuación, momento en que el servidor detectará la existencia de un conflicto, ya que se requiere validar los cambios en una copia que no ha sido actualizada con la versión del repositorio, que fue validada por el primer usuario.</p>
            <p>Será necesario hacer <b>Mark as Merged</b>. Si no se hace, Subversive sigue creyendo que hay conflicto, por lo que no dejará validar.</p>
            <div class="menuOpcional">
                <a href="../dAw.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subTres">4.3.- Documentación. Uso de comentarios. Alternativas</h3>
            <p>La documentación es el texto escrito que acompaña a los proyectos. Es un requisito importante en un proyecto comercial, ya que el cliente querrá que se documenten las distintas fases del proyecto.</p>
            <p>Tipos de documentación:</p>
            <ul>
                <li><b>Documentación de las especificaciones:</b> sirve para comprobar que tanto las ideas del desarrollador como las del cliente son las mismas, ya que, de lo contrario, el proyecto no será aceptable. Esta documentación deberá contener:
                    <ul>
                        <li><b>Introducción:</b> se explican los fines y objetivos del software</li>
                        <li><b>Descripción de la información:</b> descripción detallada, incluyendo hardware y software</li>
                        <li><b>Descripción funcional:</b> detalla cada función del sistema</li>
                        <li><b>Descripción del comportamiento:</b> explica cómo se comporta del software ante acciones externas e internas</li>
                        <li><b>Criterios de valización:</b> documento sobre el límite de rendimiento, los tipos de pruebas, la respuesta esperada del software y las consideraciones especiales</li>
                    </ul>
                </li>
                <li><b>Documentación del diseño:</b> en este documento se describe toda la estructura interna del programa, formas de implementación, contenido de clases, métodos, objetos, etc.</li>
                <li><b>Documentación del código fuente:</b> durante el desarrollo del proyecto se debe ir comentando en el código fuente cada parte, para tener una mayor claridad de lo que se quiere conseguir en cada sección.</li>
                <li><b>Documentación de usuario final:</b> documentación que se entrega al cliente en la que se describe cómo usar las aplicaciones del proyecto.</li>
            </ul>
            <h4 class="apartado">Documentación del código fuente</h4>
            <p>La documentación del código es fundamental para actualización y reparación de errores. Debe describir lo que se está haciendo y por qué.</p>
            <ul>
                <li>Todos los programas poseen errores y es cuestión de tiempo que se detecten</li>
                <li>Todos los programas sufren modificaciones a lo largo de su vida</li>
            </ul>
            <p>Es necesario que el código esté bien documentado para localice los cambios que quiere realizar.</p>
            <p>Habrá que explicar lo que realiza una clase o un método y por qué y para qué lo hace.</p>
            <p>Para documentar existen muchas herramientas, PHPDoc, PHPDocumentor, Javadoc o JSDoc.</p>
            <h4 class="apartado">4.3.1.- Uso de Javadoc en Eclipse</h4>
            <p>Javadoc es una herramienta de Java que sirve para extraer y generar documentación básica para el programador a partir del código fuente en formato HTML. Tendremos que escribir los comentarios, y el código y la documentación se encontrarán dentro del mismo fichero. Tipos de comentarios:</p>
            <ul>
                <li><b>Comentarios de línea:</b> comienzan con los caracteres "//" y terminan en la misma línea</li>
                <li><b>Comentarios de bloque:</b> comienzan con "/*" y terminan con "*/". Pueden contener varias líneas</li>
                <li><b>Comentarios de documentación Javadoc:</b> se colocan entre delimitadores "/**...*/", podrán agrupar varias líneas y cada línea irá precedida por un "*". Deberá colocarse antes de la declaración de una clase, un campo, un método o un conductor. Podrá contener etiquetas HTML y los comentarios están formados por una descripción seguida de un bloque de tags</li>
            </ul>
            <h4 class="apartado">Uso de etiquetas de documentación</h4>
            <p>Las etiquetas de Javadoc van precedidas por "@" y las más utilizadas son:</p>
            <table>
                <thead>
                    <tr>
                        <th>Etiqueta</th>
                        <th>Descripción</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>@author</td>
                        <td>Autor de la clase. Solo para clases</td>
                    </tr>
                    <tr>
                        <td>@version</td>
                        <td>Versión de la clase. Solo para clases</td>
                    </tr>
                    <tr>
                        <td>@see</td>
                        <td>Referencia a otra clase</td>
                    </tr>
                    <tr>
                        <td>@param</td>
                        <td>Descrpción del parámetro. Una etiqueta por cada parámetro</td>
                    </tr>
                    <tr>
                        <td>@return</td>
                        <td>Descripción de los que devuelve. Solo si no es void</td>
                    </tr>
                    <tr>
                        <td>@throws</td>
                        <td>Descripción de la excepción que puede propagar. Habrá una etiqueta throws por cada tipo de excepción</td>
                    </tr>
                    <tr>
                        <td>@since</td>
                        <td>Número de versión del producto</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Generar la documentación</h4>
            <p>Casi todos los entornos de desarrollo incluyen un botón para poder configurar Javadoc.</p>
            <ul>
                <li>En Javadoc Command se indicará dónde se encuentra el fichero ejecutable de Javadoc, el javadoc.exe. Pulsamos en Configure para buscarlo dentro de la carpeta workspace</li>
                <li>En los cuadros inferiores elegiremos el proyecto y las clases que documentar</li>
                <li>Elegimos la privacidad de los elementos: con Private se documentarán todos los miembros públicos, privados y protegidos</li>
                <li>Para finalizar, se indica la carpeta de destino en la que se almacenará el código <HTML></HTML></li>
                <li>Pulsar en Next, en la siguiente ventana poner el título del documento HTML que se genera y elegir las opciones para la generación de las páginas HTML. Como mínimo, se seleccionarán la barra de navegación y el índice.</li>
            </ul>
            <div class="menuOpcional">
                <a href="../dAw.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
        </div><!-- Fin contenedorApuntes -->
        <footer class="pieApuntes"><div>- SapheryDesings -</div></footer>
    </body>
</html>