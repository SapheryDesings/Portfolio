<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../css/clases.css">
  <link rel="stylesheet" href="../../css/mediaQ.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Smooch&family=Titan+One&display=swap" rel="stylesheet">
  <title>Entorno de Desarrollo</title>
</head>
    <body>
        <header>
            <div class="navtop">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html">Entorno de Desarrollo</a>
                <a href="../../index.html">Principal</a>
            </div>
        </header>
        <div class="contenedorApuntes">
            <h2 class="tituloTema" id="subUno">Tema 1. - Desarrollo de software</h2>
            
            <!--*********************************************************************-->
            <h3 class="subTitulo">El software del ordenador</h3>
            <p>La parte física, que llamamos <b>hardware</b> y que está compuesta por elementos físicos como el teclado, el ratón, el monitor, los discos duros o la placa base.</p>
            <p>El ordenador posee otra parte lógica llamada <b>software</b>, encargada de dar instrucciones al hardware y hacer funcionar la computadora.</p>
            <p>Podemos dividir el fostware en dos: según las tareas que realiza y según su método de distribución.</p>

            <h4 class="apartado">1.1.1. Software basado en el tipo de trabajo que realizan</h4>
            <ul>
                <li><b>Software de sistema:</b> es el que hace que el hardware funciones.</li>
                <li><b>Software de aplicación:</b> son los programas que realizan tareas específicas.</li>
                <li><b>Software de programación o desarrollo:</b> herramientas necesarias para escribir los programas informáticos y para hacer uso de distintos lenguajes de programación.</li>
            </ul>

            <h4 class="apartado">1.1.2. Software basado en el método de distribución</h4>
            <ul>
                <li><b>Shareware:</b> puede evaluar de forma gratuita el producto, pero con limitaciones.</li>
                <li><b>Freeware:</b> de forma gratuita, pero que mantiene los derechos de autor.</li>
                <li><b>Adware:</b> se ofrece publicidad incrustada, incluso durante la instalación de este.</li>
            </ul>
          
            <h4 class="apartado">1.1.3. Licencias de software. Software libre y propietario</h4>
            <p>Una <b>licencia</b> es un contrato entre el desarrollador de un software y el usuario final. <br> Existen dos tipos de licencias:</p>
            <ul>
                <li><b>Software libre:</b> el autor concede libertades al usuario:
                    <ul>
                        <li>Libertad para usar el programa con cualquier fin.</li>
                        <li>Libertad para saber cómo funciona el programa y adaptar el código a nuestras propias necesidades.</li>
                        <li>Libertad para poder compartir copias con otros usuarios.</li>
                        <li>Libertad para poder mejorar el programa y publicar las modificaciones realizadas.</li>
                    </ul>
                </li>
                <p>"Libre" no significa que sea gratis, es un concepto de libertad, no de precio.</p>
                <li><b>Software propietario:</b> no nos permitirá acceder al código fuente del programa, nos prohibirá la redistribución, la reprogramación, la copia o el uso simultáneo en varios equipos.</li>
            </ul>
            <p>La licencia que más se usa en el software libre es la licencia <b>GPL</b>, que nos dejará usar y cambiar el programa, con el único requisito de que se hagan públicas las modificaciones realizadas.</p>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subDos">1.2. - Concepto de programa informático</h3>
            <p>Un <b>programa informático</b> es un fragmento de software formado por una secuencia de instrucciones y procesos construidos con el fin de cumplir un objetivo concreto. Están escritos utilizando lenguajes de programación y deben ser traducidos al lenguaje máquina.</p>
            <h4 class="apartado">1.2.1. Programa y componentes del sistema informático</h4>
            <p>La arquitectura de nuestra CPU está basado en la arquitectura de <b>Von Neumann</b>.</p>
            <p>Tenemos otra estructura que es la llamada <b>Harvard</b>. La característica fundamental es eque tanto la memoria RAM como la memoria de instrucciones no comparten características comunes.</p>
            <p>La unidad de control UC es el centro de la arquitectura y conecta con la unidad aritmético-lógica UAL, los dispositivos de entrada y salida y con ambar memorias mencionadas anteriormente.</p>
            <p>En la arquitectura de Von Neumann, puede estar leyedendo o bien escribir pero ambos no pueden ocurrir a la vez.</p>
            <p>En la arquitectura Harvard, puede tanto leer una instrucción como realizar un acceso de memoria de datos.</p>
            <ul>
                <li><b>La unidad de control UC:</b> se encarga de interpretar y ejecutar las instrucciones que se almacenan en la memoria principal y, genera las señales de control necesarias para ejecutarlas.</li>
                <li><b>La unidad aritmético-lógica UAL:</b> es la que recibe los datos y ejecuta operaciones de cálculo y comparaciones, además de tomar decisiones lógicas (si son verdaderas o falsas), pero siempre supervisadas por la unidad de control.</li>
                <li><b>Los registros:</b> son aquellos que almacenan la información temporal. Es el almacenamiento interno de la CPU.</li>
            </ul>
            <p>Diferentes registros que posee la UC:</p>
            <ul>
                <li><b>Contador de programa CP:</b> contendrá la dirección de la siguiente instrucción para realizar. Su valor será actualizado por la CPU después de capturar una instrucción.</li>
                <li><b>Registro de instrucción RI:</b> es el que contiene el código de la instrucción, se analiza dicho código. Consta de dos partes: el código de la operación y la dirección de memoria en la que opera.</li>
                <li><b>Registro de dirección de memoria RDM:</b> tiene asignada una dirección correspondiente a una posición de memoria que va a almacenar la información mediante el bus de direcciones.</li>
                <li><b>Registro de intercambio de memoria RIM:</b> recibe o envía, según si es una operación de lectura o escritura, la información o dato contenido en el la posición apuntada por el RDM.</li>
                <li><b>Decodificador de instrucción DI:</b> extrae y analiza el código de la instrucción contenida en el RI.</li>
                <li><b>El reloj:</b> marca el ritmo del DI y nos proporciona unos impulsos eléctricos con intervalos constantes a la vez que marca los tiempos para ejecutar las instrucciones.</li>
                <li><b>El secuenciador:</b> son órdenes que se sincronizan con el reloj para que ejecuten correctamente y de forma ordenada la instrucción.</li>
            </ul>
            <p>Cuando ejecutamos una instrucción podemos distinguir dos fases:</p>
            <ul>
                <li><b>1. Fase de búsqueda:</b> se localiza la instrucción en la memoria principal y se envía a la unidad de control para poder procesarla.</li>
                <li><b>2. Fase de ejecución:</b> se ejecutan las acciones de las instrucciones.</li>
            </ul>
            <p>Para que podamos realizar operaciones de lectura y escritura en una celda de memoria, se utilizan el RDM, el RIM y el DI. El decodificador de instrucción es el encargado de conectar la celda RDM con el registro de intercambio RIM, el cual posibilita que la trasferencia de datos se realice en un sentido u otro según sea de lectura o escritura.</p>
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subTres">1.3. - Código fuente, código objeto y código ejecutable. Máquinas virtuales</h3>
            <h4 class="apartado">1.3.1. Tipo de código</h4>
            <p>Cuando escribamos un código, pasa por distintos estados:</p>
            <ul>
                <li><b>Código fuente:</b> es el código realizado por los programadores, en un lenguaje de alto nivel y para escribirlo se parte de, diagramas de clases. No se puede ejecutar directamente en el ordenador.</li>
                <li><b>Código objeto:</b> es el código que se crea tras realizar la compilación, no es entendido ni por el ordenador ni por nosotros. Representación intermedia de bajo nivel.</li>
                <li><b>Código ejecutable:</b> se obtiene tras unir el código objeto con varias librerías para que así pueda ser ejecutado por el ordenador.</li>
            </ul>
            <h4 class="apartado">1.3.2. Compilación</h4>
            <p>Es el proceso a través del cual se convierte un programa en lenguaje máquina a partir de otro programa de computadora escrito en otro lenguaje. Se realiza a través de dos programas: el compilador y el enlazador. Si en el <b>compilador</b> se detecta algún tipo de error no se generará el código objeto y tendremos que modificar el código fuente.</p>
            <ul>
                <li><b>Análisis léxico:</b> se lee el código obteniendo unidades de caracterres llamados tokens.</li>
                <li><b>Análisis sintáctico:</b> recibe el código fuente en forma de tokens y ejecuta el análisis para determinar la estructura del programa, se comprueba si cumplen las reglas sintácticas.</li>
                <li><b>Análisis semántico:</b> revisa que las declaraciones sean correctas, los tipos de todas las expresiones, si las operaciones se pueden realizar.</li>
                <li><b>Generación de código intermedio:</b> después de analizarlo todo, se crea una representación similar al código fuente para facilitar la tarea de traducir al código objeto.</li>
                <li><b>Optimización de código:</b> se mejora el código intermedio anterior para que sea más fácil y rápido a la hora de interpretarlo la máquina.</li>
                <li><b>Geración de código:</b> se genera el código objeto.</li>
            </ul>
            <p>El <b>enlazador</b> insertará en el código objeto las librerías necesarias para que se pueda producir un programa ejecutable. Si se hace referencia a otros ficheros que contengan las librerías especificadas en el código objeto, se combina con dicho código y se crea el fichero ejecutable.</p>
            <h4 class="apartado">1.3.3. Máquinas virtuales</h4>
            <p>Una máquina virtual es un tipo de software capaz de ejecutar programas como si fuese una máquina real.</p>
            <ul>
                <li><b>De sistema:</b> permiten virtualizar máquinas con distintos sistemas operativos en cada una.</li>
                <li><b>De proceso:</b> Se ejecutan como un proceso normal dentro de un sistema operativo y solo soportan un proceso. El objetivo es proporcionar un entorno de ejecución independiente del hardware y del sistema operativo y permitir que el programa sea ejecutado de la misma forma en cualquier plataforma.</li>
            </ul>
            <h4 class="apartado">La máquina virtual de Java</h4>
            <p>Los programas que se compilan en lenguaje Java son capaces de funcionar en cualquier plataforma. El código no lo ejecuta el procesador del ordenador sino la propia Máquina Virtual de Java. El funcionamiento es el siguiente:</p>
            <ul>
                <li>1. El código fuente estará escrito en archivos de texto planos con la extensión .java.</li>
                <li>2. El compilador <b>javac</b> generará uno o varios archivos, siempre que no se produzcan errores, y tendrán la extensión .class.</li>
                <li>3. Este fichero contendrá un lenguaje intermedio bytecode.</li>
                <li>4. La JVM coge y traduce mediante un compilador JIT el bytecode en código binario para que el procesador de nuestro ordenador sea capaz de reconocerlo.</li>
                <li>5. Los ficheros .class podrán ser ejecutados en múltiples plataformas.</li>
            </ul>
            <p>La máquina virtual de Java contiene las siguientes tareas:</p>
            <ul>
                <li>Carga y almacenamiento de datos.</li>
                <li>Excepciones (errores en tiempo de ejecución).</li>
                <li>Operaciones aritméticas.</li>
                <li>Conversiones de tipos de datos.</li>
                <li>Llamadas a métodos y devolución de datos.</li>
                <li>Creación y manejo de objetos.</li>
            </ul>
            <p>Las desventajas, puede ser que son más lentos que los ya compilados, debido a la capa intermedia.</p>
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subCuatro">1.4. - Tipos de lenguajes de programación. Clasificación y características de los lenguajes más difundidos</h3>
            <p>Lenguaje de programación hace referencia al conjunto de caracteres, reglas y acciones combinadas y consecutivas que un equipo debe ejecutar. Constará de los siguientes elementos:</p>
            <ul>
                <li><b>Alfabeto o vocabulario:</b> conjunto de símbolos permitidos.</li>
                <li><b>Sintaxis:</b> reglas para realizar correctamente construcciones con los símbolos.</li>
                <li><b>Semántica:</b> reglas que determinan el significado de contrucción del lenguaje.</li>
            </ul>
            <h4 class="apartado">1.4.1. Clasificación y características</h4>
            <p>Podemos clasificar los lenguajes de programación basándonos en los siguientes criterios:</p>
            <table>
                <tbody>
                    <tr>
                        <th>Según su nivel de abstracción</th>
                        <td>Lenguajes de bajo nivel. <br>
                        Lenguajes de nivel medio. <br> 
                        Lenguajes de alto nivel.
                        </td>
                    </tr>
                    <tr>
                        <th>Según la forma de ejecución:</th>
                        <td>Lenguajes compilados. <br> 
                        Lenguajes interpretados. <br>
                        </td>
                    </tr>
                    <th>Según el paradigma de programación:</th>
                    <td>Lenguajes imperativos. <br>
                        Lenguajes funcionales. <br>
                        Lenguajes lógicos. <br>
                        Lenguajes estructurados. <br>
                        Lenguajes orientados a objetos. <br>
                    </td>
                </tbody>
            </table>
            <h4 class="apartado">Según su nivel de abstracción</h4>
            <p><b>Lenguajes de bajo nivel:</b> el de más bajo nivel es <b>el lenguaje máquina.</b> Utiliza el lenguaje binario y los programas son específicos para cada procesador. Al lenguaje máquina le sigue el <b>lenguaje ensamblador</b>. Complicado de aprender y es específico para cada procesador. Este lenguaje tiene que ser traducido al lenguaje máquina. Se utilizan nombres mnemotécnicos y las instrucciones trabajan directamente con registros de memoria física.</p>
            <ul>
                <li>Los registros extendidos de 32 bits, como EAX (registro acumulador), EBX (registro de índice base), ECX (registro de conteo) o EDX (registro de datos).</li>
                <li>Estos registros se dividen en registros de menor tamaño, como AX, BX, CX Y DX, de 16 bits, y estos, a su vez, en otros de 8 bits, como AH, AL, BH, BL, CH, CL, DH o DL.
                    <ul>
                        <li><b>EAX:</b> el acumulador se utiliza para instrucciones tales como multiplicación o división.</li>
                        <li><b>EBX:</b> guarda la dirección de desplazamiento de una posición en el sistema de memoria.</li>
                        <li><b>ECX:</b> es un registro de propósito general que guara la cuenta de varias instrucciones. Realiza funciones de contador.</li>
                        <li><b>EDX:</b> es un registro de propósito general que almacena datos de, por ejemplo, aplicaciones aritméticas como el divisor antes de hacer una división.</li>
                    </ul> <br>
                    Podemos realizar operaciones con estos registros.
                </li>
            </ul>
            <p><b>Lenguajes de nivel medio:</b> poseen características de ambos tipos de nivel, tanto del nivel bajo como del alto, y se suele usar para la creación de sitemas operativos.</p>
            <p><b>Lenguajes de alto nivel:</b> es más fácil a la hora de aprender, utilizan nuestro lenguaje natural. Para poder ejecutar lo que escribamos, necesitaremos un compilador para que traduzca al lenguaje máquina las intrucciones. Es independiente de la máquina, no depende del hardware.</p>
            <h4 class="apartado">Según la forma de ejecución</h4>
            <p><b>Lenguajes compilados:</b> al programar en alto nivel, hay que traducir ese lenguaje a lenguaje máquina a través de compiladores. Devolverán errores si el lenguaje fuente está mal escrito y lo ejecutarán si el lenguaje destino es ejecutable por la máquina.</p>
            <p><b>Lenguajes interpretados:</b> otra variante para traducir programas de alto nivel. Cuando ejecutamos una instrucción, se debe interpretar y traducir al lenguaje máquina. El compilador es, más rápido que un intérprete, al usar el intérprete evitaremos tener que compilar cada vez que hagamos alguna modificación. Java usa tanto la compilación como la interpretación, puede compilarse primero en un formato intermedio, llamado bytecodes, para que luego una máquina virtual lo interprete.</p>
            <h4 class="apartado">Según el paradigma de programación</h4>
            <p>El paradigma de programación nos detalla las reglas, patrones y los estilos de programación que usan los lenguajes. Pueden usar más de un paradigma.</p>
            <p><b>Lenguajes imperativos:</b> los primeros lenguajes imperativos que se usaron fueron el lenguaje máquina y el lenguaje ensamblador. Consisten en una serie de sentencias que establecen cómo debe manipularse la información presente en cada memoria o cómo se debe enviar o recibir la información. Las estructuras de control podemos establecer el orden en que se ejecutan y modificar el flujo del programa según los resultados de las acciones. Casi todos los <b>lenguajes de desarrollo de software comercial</b> son imperativos.</p>
            <ul>
                <li><b>Programación estructurada.</b></li>
                <li><b>Programación modular.</b></li>
                <li><b>Programación orientada a objetos.</b></li>
            </ul>
            <p><b>Lenguajes funcionales:</b> están basados en el concepto de función y estarán formados por definiciones de funciones junto con sus argumentos. Entre sus características destaca que no existe la operación de asignación. Las variables almacenan definiciones a expresiones. El resultado de un cálculo es la entrada del siguiente, y así sucesivamente hasta que se consigue el valor deseado. Apenas se usar para el software comercial.</p>
            <p><b>Lenguajes lógicos:</b> están basados en el concepto de razonamiento, deductivo o inductivo. A partir de una base de datos consistente en un conjunto de entidades, propiedades de esas entidades o relaciones entre entidades, el sistema es capaz de hacer <b>razonamientos</b>. Los programas escritos en este lenguaje suelen tener forma de una <b>base de datos</b>, está formada por declaraciones lógicas, que son ciertas o falsas, que podremos consultar. La ejecución será en forma de consultas hacia esa base de datos. El lenguaje lógico más importante es Prolog.</p>
            <p><b>Lenguajes estructurados:</b> utilizan las tres construcciones lógicas y resultan fáciles de leer. El inconveniente es el código, que está centrado en un solo bloque, lo que dificulta el proceso de hallar el problema. Nos estamos refiriendo a programas creados a través de modulos, pequeñas partes más manejables que unidas entre sí, hacen que el programa funcione. Cada módulo poseen una entrada y una salida y deben estar perfectamente comunicados, aunque cada uno de llos trabaja de forma independiente.</p>
            <p>La evolución a esta programación mediante módulos se le denomina <b>programación modular</b> y posee las siguientes ventajas:</p>
            <ul>
                <li>Al dividir el programa en módulos, varios programadores podrán trabajar a la vez en cada uno de ellos.</li>
                <li>Estos módulos pueden usarse para otras aplicaciones.</li>
                <li>Si surge algún problema será más fácil y menos costoso detectarlo y abordarlo, ya qe se puede resolver de forma aislada.</li>
            </ul>
            <p><b>Lenguajes orientados a objetos:</b> estarán definidos por un conjunto de objetos en vez de por módulos.</p>
            <p>Estos objetos están formados por una estructura de datos y por una colección de métodos que enterpretan esos datos. Los datos que se encuentran dentro de los objetos son sus <b>atributos</b>, y las operaciones que se realizan sobre los objetos cambian el valor de uno o más atributos.</p>
            <p>La comunicación entre objetos se realiza a través de mensajes.</p>
            <p>Una clase es una plantilla para creación de objetos. Al crear un objeto, se ha de especificar a qué clase pertenece para que el compilador sepa qué características posee.</p>
            <p>Las ventajas, destacar la facilidad para reutilizar el código, el trabajo en equipo o el mantenimiento del software.</p>
            <p>Una desventaja es que el concepto de un programador puede ser distinto a otros.</p>
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subCinco">1.5. - Fases del desarrollo de una aplicación: análisis, diseño, codificación, pruebas, documentación, mantenimiento y explotación</h3>
            <p>Cuando queramos realizar un proyecto de software, antes debemos crear un ciclo de vida en el que examinemos las características para eligir un modelo de desarrollo u otro.</p>
            <h4 class="apartado">Modelo en cascada</h4>
            <p>Las etapas para el desarrollo de software tienen un orden, para empezar una etapa, es necesario finalizar la etapa anterior. Después de cada etapa se realiza una revisión para comprobar si se puede pasar a la siguiente.</p>
            <p>Permite hacer iteraciones, es decir, si se tiene que volver a una de las etapas anteriores, hay que recorrer de nuevo el resto de etapas.</p>
            <p>Tiene distintas variantes, una de las más utilizadas es el <b>modelo en cascada con retroalimentación</b>, en las etapas se detectan fallos, entonces, será necesario retornar a la etapa anterior para realizar los ajustes pertinentes. Se le conoce como retroalimentación.</p>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Fácil de comprender, planificar y seguir.</td>
                        <td>La necesidad de tener todos los requisitos definidos desde el principio.</td>
                    </tr>
                    <tr>
                        <td>La calidad del producto resultante es alta.</td>
                        <td>Es difícil volver atrás si se comenten errores en una etapa (es un modelo inflexible)</td>
                    </tr>
                    <tr>
                        <td>Los recursos que se necesitan son mínimos.</td>
                        <td>El producto no está disponible para su uso hasta que no está completamente terminado.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda cuando:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">El proyecto es similar a alguno que ya se haya realizado con éxito anteriormente.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Los requisitos son estables y están bien comprendidos.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Los clientes no necesitan versiones intermedias.</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Modelo iterativo incremental</h4>
            <p>Basado en varios ciclos en cascada realimentados aplicados repetidamente.</p>
            <p>Entrega el software en partes pequeñas, pero utilizables, llamadas incrementos o prototipos.</p>
            <p>Cada incremento se construye sobre aquel que ya ha sido entregado.</p>
            <p>Al desarrollar el software de manera incremental, resulta más barato y fácil realizar cambios en el software conforme este se va desarrollando.</p>
            <p>Cada incremento del aplicativo incorpora algunas de las funciones que necesita el cliente. Esto significa que el cliente puede evaluar el desarrollo del sistema en una etapa temprana.</p>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>No necesitan conocer todo los requisitos. Se reduce, por tanto, el coste de adaptar los requerimientos cambiantes del cliente.</td>
                        <td>Es difícil estimar el esfuerzo y el coste final necesarios.</td>
                    </tr>
                    <tr>
                        <td>Permite la entrega temprana al cliente de partes operativas del software.</td>
                        <td>Se tiene el riesgo de no acabar nunca.</td>
                    </tr>
                    <tr>
                        <td>Las entregas facilitan la realimentación de los próximos entregables.</td>
                        <td>No es recomendable para desarrollo de sistemas de tiempo real, de alto nivel de seguridad, de procesamiento distribuido y/o de alto índice de riesgos.</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>La incorporación de muchos cambios hace que el software se vuelva inestable.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda cuando:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">Los requisitos o el diseño no están completamente definidos y es posible que haya grandes cambios.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Se están probando o introduciendo nuevas tecnologías.</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Modelo en espiral</h4>
            <p>Combina el modelo en cascada con el modelo iterativo de construcción de prototipos. Se representa como una espiral donde en cada ciclo se desarrolla una parte de este. Cada ciclo está formado por cuatro fases y produce una versión incremental del software con respecto al ciclo anterior. Se parece al modelo iterativo incremental, con la diferencia de que en cada ciclo se tiene en cuenta el análisis de riesgos. Para cada ciclo, los desarrolladores siguen estas fases:</p>
            <ul>
                <li><b>1. Determinar objetivos:</b> cada ciclo comienza con la identificación de los objetivos, las alternativas para alcanzar los objetivos y  las restricciones impuestas a la aplicación de las alternativas.</li>
                <li><b>2. Análisis del riesgo:</b> hay que evaluar las alternativas en relación con los objetivos y limitaciones. En este proceso se identifican los riesgos involucrados y la manera de resolverlos. Se aconseja realizar un análisis minucioso para reducir los riesgos. Utiliza la construcción de prototipos como mecanismo de reducción de riesgos.</li>
                <li><b>3. Desarrollar y probar:</b> desarrollar la solución al problema en este ciclo y verificar que es aceptable.</li>
                <li><b>4. Planificación:</b> revisar y evaluar todo lo que se ha hecho y, con ello, decidir si se continúa; entonces hay que planificar las fases del ciclo siguiente.</li>
            </ul>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>No requiere una definición completa de los requisitos para empezar a funcionar.</td>
                        <td>Es difícil evaluar los riesgos.</td>
                    </tr>
                    <tr>
                        <td>Análisis del riesgo en todas las etapas.</td>
                        <td>El costo del proyecto aumenta a medida que la espiral pasa por sucesivas iteraciones.</td>
                    </tr>
                    <tr>
                        <td>Reduce riesgos del proyecto.</td>
                        <td>El éxito del proyecto depende en gran medida de la fase de análisis de riesgos.</td>
                    </tr>
                    <tr>
                        <td>Aumento de la productividad.</td>
                        <td>Es difícil hacer ver al cliente que este enfoque evolutivo es controlable.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda para:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">Proyectos de gran tamaño y que necesitan constantes cambios.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Proyectos donde sea importante el factor riesgo.</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Modelo en V</h4>
            <p>Es un proceso que representa la secuencia de pasos en el desarrollo del ciclo de vida de un proyecto. En él se describen las actividades y resultados que deben producirse durante el desarrollo del producto. El <b>lado izquierdo</b> representa la descomposición de las necesidades y la creación de las especificaciónes. El <b>lado derecho</b> representa la integración de las piezas y su verificación.</p>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Facilita la localización de fallos.</td>
                        <td>Las pruebas pueden llegar a ser costosas.</td>
                    </tr>
                    <tr>
                        <td>Modelo muy sencillo.</td>
                        <td>El cliente debe tener paciencia hasta el producto final.</td>
                    </tr>
                    <tr>
                        <td>El cliente está involucrado en las pruebas.</td>
                        <td>Pueden no estar bien definidos los requisistos del cliente.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda para:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">Ser aplicado en sistemas sencillos pero de confiabilidad alta (transacciones en bases de datos).</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">1.5.1. Análisis</h4>
            <p>La parte más importante es entender qué se quiere realizar y analizar las posibilidades alternativas y soluciones. Es <b>fundamental</b> analizar los requisitos que el cliente ha solicitado.</p>
            <p>El análisis consiste en la especificación de las características operativas del software, indica cuál es la interfaz que ha de desarrollarse y marca las restricciones de este.</p>
            <p>Aunque pueda parecerlo, no es una tarea fácil, ya que a menudo el cliente es poco claro y durante el desarrollo pueden surgir nuevos requerimientos. Para la obtención d estos requisitos, se usarán distintas técnicas:</p>
            <ul>
                <li><b>Entrevistas:</b> En un ambiente más relajado, el cliente tiende a expresarse con más claridad.</li>
                <li><b>Desarrollo conjunto de aplicaciones:</b> entrevista de dinámica de grupo en la que cada integrante aporta su conocimiento.</li>
                <li><b>Planificación conjunta de requisitos:</b> el objetivo es involucrar a la dirección para obtener mejores resultados en el menor tiempo. La diferencia es la participación del nivel más alto de la organización en la visión general del negocio.</li>
                <li><b>Brainstorming:</b> se intentan crear ideas desde distintos puntos de vista. Idónea para el comienzo del proyecto.</li>
                <li><b>Prototipos:</b> versión inicial del sistema en el que se puede ver el problema y sus posibles soluciones. Se puede desechar o usar para añadir más cosas.</li>
                <li><b>Casos de uso:</b> son una ayuda para definir lo que existe fuera del sistema y lo que debe realizar el sistema son fundamentales en la ingeniería de requisistos.</li>
            </ul>
            <p>Requisitos:</p>
            <ul>
                <li><b>Requisitos funcionales:</b> nos describen al detalle la función que realiza el sistema, la reacción ante determinadas entradas y cómo se comporta en distintas situaciones.</li>
                <li><b>Requisitos no funcionales:</b> son limitaciones sobre la funcionalidad que ofrece el sistema. Se refieren a las propiedades emergentes del sistema, como la fiabilidad o la capacidad de almacenamiento. Incluyen restricciones impuestas por el estándar del aplicativo.</li>
            </ul>
            <p>Representar estos requisitos, podemos:</p>
            <p><b>Modelo basado en el escenario:</b> se basa en el punto de vista de los actores del sistema. Lo podemos representar con los casos de uso o las historias de usuario.</p>
            <p><b>Modelo de datos:</b> muestra el entorno y la información del problema. Lo podemos representar con el diccionario de datos.</p>
            <ul>
                <li><b>Diccionario de datos:</b> descripción detallada de los datos utilizados por el sistema que gráficamente están representado por los flujos de datos y almacenes presentes sobre el conjunto de DFD. <br> En esta primera fase de análisis, todo lo que se realice quede plasmado en el documento Especificación de Requisitos de Software. Debe ser completo, sin ambigüedades, sencillo de usar a la hora de verificarlo, modificarlo o de identificar el origen y las consecuencias de los requisitos. Servirá para la siguiente fase.</li>
                <li><b>Diagrama entidad/relación:</b> se usa para representar datos y sus relaciones. Representa los datos que se introducen, almacenan y transforman en el sistema.</li>
            </ul>
            <p><b>Modelos orientados al flujo:</b> representan los elementos funcionales del sistema de tal forma que reflejan cómo se transforman los datos a medida que avanzan dentro del aplicativo.</p>
            <ul>
                <li><b>Diagramas de flujo de datos:</b> nos va a representar el flujo de datos entre procesos, entidades externas y almacenes del sistema:</li>
                <ul>
                    <li><b>Procesos:</b> burbujas ovaladas o circulares.</li>
                    <li><b>Entidades externas:</b> rectángulos.</li>
                    <li><b>Almacenes:</b> dos líneas horizontales y paralelas.</li>
                    <li><b>Flujo de datos:</b> flechas.</li>
                </ul>
                <li><b>Diagramas de flujo de control:</b> en vez de flujo de datos muestra el flujo de control. Producen información de control y procesan información con mucha atención al tiempo y al rendimiento.</li>
                <li><b>Diagramas de transición de estados:</b> representa el comportamiento del sistema dependiente del tiempo.</li>
            </ul>
            <h4 class="apartado">1.5.2. Diseño</h4>
            <p><b>Diseño estructurado:</b> en la programación estructurada existen una serie de contrucciones: secuencial, condicional y repetitiva</p>
            <ul>
                <li><b>Construcción secuencial:</b> se refiere a la ejecución sentencia por sentencia hasta que no termine la ejecución de una sentencia, no pasará a la siguiente.</li>
                <li><b>Construcción condicional:</b> selecciona un proceso u otro según una condición lógica(rombo). Si se cumple, se realiza la parte SI, si no, se realiza la parte NO. <br> La selección múltiple es una extensión de la estructura Si entonces si-no se prueba hasta que alguna es verdadera y ejecuta según ese camino.</li>
                <li><b>Construcción repetitiva:</b>
                    <ul>
                        <li><b>Hacer hasta:</b> se ejecuta una primera vez la tarea y al finalizarla se comprueba la condición. Si esta no se cumple, se realiza de nuevo hasta que se cumpla la condición y finalice la tarea. Se realiza al menos una vez.</li>
                        <li><b>Mientras:</b> se comprueba antes la condición y,  después, se realiza la tarea continuamente siempre que se cumpla la condición. Finaliza cuando la condición no se cumpla.</li>
                    </ul>
                </li>
            </ul>
            <p>El diseño estructurado podemos dividirlo en:</p>
            <ul>
                <li><b>Diseño de datos:</b> Transforma la información relativa al análisis en estructuras de datos para su posterior implementación.</li>
                <li><b>Diseño arquitectónico:</b> Es un esquema similar al plano de una casa. Se centra en el representación de la estructura de los componentes del software, sus propiedades y sus interacciones. Este diseño se basa en la información del entorno del aplicativo que realizar y de los modelados de requerimientos.</li>
                <li><b>Diseño de la interfaz:</b> Detalla la comunicación que realiza el software consigo mismo, los sistema que operan con él y los usuarios. Los elementos importantes son la interfaz de usuario (UI) e interfaces externas con otros sistemas, dispositivos o redes.</li>
                <li><b>Diseño a nivel de componentes(procedimental):</b> Similar a los planos de cada habitación de una casa. Convierte elementos estructurales de la arquitectura del software en una descripción procedimental de los componentes del software. El resultado será el diseño de cada componente con el detalle necesario para que sirva de guía en la generación del código fuente. Se realiza mediante diagramas de flujo, diagramas de cajas, tabla de decisión, pseudocódigo, etcétera.</li>
            </ul>
            <h4 class="apartado">Notaciones gráficas para el diseño procedimental</h4>
            <p>Al representar el diseño, usaremos diagramas de flujo, los diagramas de cajas, las tablas de decisión o el pseudocódigo.</p>
            <p><b>Diagramas de cajas:</b> otra representación de diseño estructurado:</p>
            <ul>
                <li><b>Secuencia:</b> varias cajas seguidas.</li>
                <li><b>Condicional:</b> una caja para la parte SI y otra para la parte NO. Encima indicamos la condición.</li>
                <li><b>Repetitiva:</b> proceso que se repite, se encierra en una caja que se sitúa dentro de otra en la que indicamos la condición del bucle en la parte superior (while) o inferior (do-while).</li>
                <li><b>Selección múltiple:</b> la parte superior indica el caso de condición, mientras que en la parte inferior se definen tantas columnas como valores se quieran comprobar. Debajo de cada valor se indica la parte que se debe ejecutar.</li>
            </ul>
            <p><b>Tablas de decisión:</b> nos permiten representar en una tabla las condiciones y las acciones que se llevarán a cabo al combinar esas condiciones. Proporcionan una notación que traduce las acciones y condiciones a una forma estructurada. Se dividirá en dos:</p>
            <ul>
                <li><b>Condiciones:</b> son las combinaciones posibles de nuestro sistema.</li>
                <li><b>Acciones:</b> sentencias que se ejecutan cuando se cumplen determinadas condiciones.</li>
            </ul>
            <p>Podemos implementar las reglas que se deben cumplir para una determinada acción. Seguimos los siguientes pasos:</p>
            <ul>
                <li>1. Crear una lista con todas las acciones y todas las condiciones.</li>
                <li>2. Relacionar los conjuntos con las acciones específicas, eliminando las combinaciones imposibles.</li>
                <li>3. Determinar las reglas indicando la acción o acciones que ocurren para un conjunto de condiciones.</li>
            </ul>
            <p><b>Pseudocódigo:</b> utiliza un texto descriptivo para crear el diseño de un algoritmo. Mezcla el lenguaje natural con la sintaxis de la programación estructurada, incluyendo palabras clave.</p>
            <p>No existe un estándar definido, no puede compilarse. La representación en pseudocódigo de las estructuras básicas.</p>
            <p><b>Diseño orientado a objetos (DOO):</b> Deberemos definir un conjunto de clases para afinar los detalles de nuestro sistema, lo que nos permitirá implementar una infraestructura. Cinco clases de diseño:</p>
            <ul>
                <li>Clases de interfaces: definimos todas las interacciones entre el usuario y la máquina.</li>
                <li>Clases de dominio de negocio: identificamos las claes y los métodos que se necesitan para implementar elementos del dominio.</li>
                <li>Clases de proceso: implementación a bajo nivel para la gestión de las clases de domino de negocio.</li>
                <li>Clases de persistencia: definimos el almacenamiento de los datos. Estas clases se mantendrán más allá de la ejecución de un determinado software.</li>
                <li>Clases de sistema: se definen funciones que permiten al sistema comunicarse con el exterior.</li>
            </ul>
            <p>Utilizamos un <b>UML</b> (lenguaje de modelado unificado). Es un lenguaje de modelado basado en diagramas para expresar modelos anteriores.</p>
            <h4 class="apartado">1.5.3. Codificación</h4>
            <p>La tercera fase, consistirá en el proceso de codificación. Se encarga de recibir los datos del diseño y transformarlo en lenguaje, le llamaremos <b>código fuente</b>.</p>
            <p>En un grupo, habrá que tener unas normas de codificación y estilo que sean <b>sencillas, claras y homogéneas</b>, facilitará la corrección.</p>
            <p>Normas en código Java:</p>
            <p><b>Nombre de ficheros:</b> los archivos de código fuente tendrán como extensión .java, y los archivos compilados .class.</p>
            <p><b>Organización de ficheros:</b> cada archivo deberá tener una clase pública y podrá tener otras clases privadas e interfaces que irán definidas después de la pública y estarán asociadas a esta. El archivo se dividirá en varias secciones:</p>
            <ul>
                <li><b>Comentarios:</b> cada archivo debe empezar con un comentario en el que se indique el nombre de la clase, la información de la versión, la fecha y el aviso de derechos de autor.</li>
                <li><b>Sentencias de tipo package e import:</b> se sitúan después de los comentarios en este orden: primero la sentencia package y después la de import.</li>
                <li><b>Declaraciones de clases e interfaces:</b> consta de las siguientes partes:
                    <ul>
                        <li>Comentario de documentación (/**...*/) acerca de la clases o interfaz.</li>
                        <li>Sentencia tipo class o interfaz.</li>
                        <li>Comentario de la implementación (/*...*/) de la clase o interfaz.</li>
                        <li>Variables estáticas, en este orden: públicas, protegidas y privadas.</li>
                        <li>Variables de instancia en este orden: públicas, protegidas y privadas.</li>
                        <li>Constructores.</li>
                        <li>Métodos.</li>
                    </ul>
                </li>
            </ul>
            <p><b>Indentación:</b></p>
            <ul>
                <li>Se usarán cuatro espacios como indentación.</li>
                <li>Longitud de líneas de código no superior a 80 líneas.</li>
                <li>Longitud de líneas de comentarios no superior a 70 líneas.</li>
                <li>Si una expresión no cabe en una sola línea, se deberá romper antes de una coma o un operador y se alineará al principio de la anterior.</li>
            </ul>
            <p><b>Comentarios:</b> contendrán solo información que sea relevante para la lectura y comprensión del programa. Dos tipos: documentación y de implementación.</p>
            <p>La especificación del código como las clases Java, interfaces, constructores, métodos y campos. Se situarán antes de la declaración. <b>Javadoc</b> genera páginas HTML partiendo de este tipo de comentarios.</p>
            <p>De implementación sirven para hacer algún comentario sobre la aplicación en particular.</p>
            <ul>
                <li>De bloque:</li>
                <pre>
                    <code>
                        /*
                        * Esto es un comentario de bloque
                        */
                    </code>
                </pre>
                <li>De línea:</li>
                <pre>
                    <code>
                        /* Comentario de línea */
                    </code>
                </pre>
                <li>Corto:</li>
                <pre>
                    <code>
                        // Comentario corto
                    </code>
                </pre>
            </ul>
            <p><b>Declaraciones:</b></p>
            <ul>
                <li>Declarar una variable por línea.</li>
                <li>Inicializar una variable local al comienzo, donde se declara, y situarla al comienzo del bloque.</li>
                <li>En clases o interfaces:
                    <ul>
                        <li>No poner espacios en blanco entre el nombre del método y el paréntesis "(".</li>
                        <li>Llave de apertura "{", situarla en la misma línea que el nombre del método.</li>
                        <li>Llave de cierre "}", situarla en una línea aparte y en la misma columna que el inicio del método. Excepto cuando esté vacío.</li>
                        <li>Métodos separados por una línea en blanco.</li>
                    </ul>
                </li>
            </ul>
            <p><b>Sentencias:</b></p>
            <ul>
                <li>Cada línea contendrá una sentencia.</li>
                <li>Si es un bloque, debe estar sangrado con respecto a lo anterior y entre llaves, aunque solo tenga una sentencia.</li>
                <li>Sentencias if-else, if else-if else. Nos definen bloques y tendrán todos los mismos niveles de sangrado.</li>
                <li>Bucles. Tendrán las normas anteriores y, si están vacío, no irán entre llaves.</li>
                <li>Sentencias return no irán entre paréntesis.</li>
            </ul>
            <p><b>Separaciones:</b> hacen más legible el código.</p>
            <ul>
                <li><b>Dos líneas en blanco</b> entre definiciones de clases e interfaces.</li>
                <li><b>Una línea en blanco</b> entre métodos, definición de variables locales y la primera instrucción, antes de un comentario, entre secciones lógicas dentro de un método.</li>
                <li><b>Un carácter en blanco</b> entre una palabra y un parentesis, después de una coma, de operadores binarios menos el punto, de expresiones del for y entre un cast y la variable.</li>
            </ul>
            <p><b>Nombres:</b> los nombres de las variables, métodos, clases, etcétera, hacen que los programas sean más fáciles a la hora de leerlos. Las normas para asignar nombres:</p>
            <ul>
                <li><b>Paquetes:</b> se escriben en minúscula. Se podrán utilizar puntos para algún tipo de organización jerárquica.</li>
                <li><b>Clases e interfaces:</b> deben ser sustantivas o descriptivas, según lo que estemos creando. Si están compuestas por varias palabras, la primera letra de cada palabra irá en mayúscula.</li>
                <li><b>Métodos:</b> se usarán verbos en infinitivo. Si están formados por varias palabras, el verbo estará en minúscula y la siguiente palabra empezará con mayúscula.</li>
                <li><b>Variables:</b> deben ser cortas y significativas. Si están formadas por varias palabras, la primera debe ir en minúscula.</li>
                <li><b>Constantes:</b> el nombre debe ser descriptivo. Será totalmente escrito en mayúscula y, si son varias palabras, separadas por un carácter de subrayado.</li>
            </ul>
            <p>Un ejemplo:</p>
            <ul>
                <li>1. Creamos la clase Persona con sus atributos privados y su instancia.</li>
                <pre>
                    <code>
                        package Ejemplo;
                        /**
                        * Clase utulizada para crear nuevas personas
                        * Pueden contener una edad y un nombre
                        * @autor Martin Rivero
                        * @version 1.0
                        */
                        public class Persona {
                            /**
                            * Variable privada para guardfar el nombre de la Persona
                            */
                            private String nombre;
                            /**
                            * Variable privada para guardar la edad de la Persona
                            */
                            private int edad;
                            /**
                            * Instancia una nueva persona sin nombre y sin edad.
                            */
                            public Persona() {
                            }
                            /**
                            * Instancia una nueva PErsona.
                            *
                            * @param nombre el nombre
                            * @param edad la edad
                            */
                            public Persona(String nombre, int edad) {
                            this.nombre = nombre;
                            this.edad = edad;
                            }
                    </code>
                </pre>
                <li>2. Posteriormente, creamos los getters y setters.</li>
                <pre>
                    <code>
                        /**
                        * Recupera el nombre.
                        *
                        * @return nombre
                        */
                        public String getNombre() {
                        return nombre;
                        }
                        /**
                        * Establece el nombre.
                        *
                        * @param nombre Nombre de la Persona
                        */
                        public void setNombre(String nombre) {
                        this.nombre = nombre;
                        }
                        /**
                        * Recupera la edad.
                        *
                        * @return edad
                        */
                        public int getEdad() {
                        return edad;
                        }
                        /**
                        * Establece la edad.
                        *
                        * @param edad Edad de la Persona
                        */
                        public void setEdad(int edad) {
                        this.edad = edad;
                        }
                    </code>
                </pre>
                <li>3. Creamos un método de tipo string para recuperar el nombre y la edad de la persona.</li>
                <pre>
                    <code>
                        /**
                        * Recupera la Persona en formato String..
                        *
                        * @return string de Persona
                        */
                        @Override
                        public String toString() {
                        return “persona{“ +
                        “nombre=’“ + nombre + ‘\’’ +
                        “, edad=” + edad +
                        ‘}’;
                        }
                    </code>
                </pre>
            </ul>
            <p>Lo tendremos que traducir al lenguaje máquina a través de <b>compiladores</b> o <b>intérpretes</b>. El resultado será el código objeto, no ejecutable hasta que lo enlacemos con las librerías para obtener así el <b>código ejecutable</b>. Comprobar el programa para ver si cumple con nuestras especificaciones en el diseño.</p>
            <p>Deberemos escribir <b>manuales</b> técnicos y de referencia, así como la parte inicial del manual de usuario.</p>
            <h4 class="apartado">1.5.4. Pruebas</h4>
            <p>Trataremos de encontrar errores en la codificación, en la especificación o en el diseño.</p>
            <p><b>Verificación:</b> probar que el software cumple con los requerimientos. En el documento de requerimientos, debe haber, como mínimo, una prueba por cada uno de ellos.</p>
            <p><b>Validación:</b> encontrar alguna situación donde el software sea incorrecto o no cumple con las especificaciones. Trataremos de comprobar los distintos tipos de errores. Una prueba tendrá éxito si encontramos algún error no detectado anteriormente. Recomendaciones:</p>
            <ul>
                <li>Cada prueba definirá los resultados de la salida esperados.</li>
                <li>Evitar que el programador pruebe sus propios programas.</li>
                <li>Comprobar cada resultado en profundidad.</li>
                <li>Incluir todo tipo de datos, tanto válido y esperados como inválidos e inesperados.</li>
                <li>Comprobar que el software hace lo que debe y lo que no debe hacer.</li>
                <li>No hacer pruebas que no estén documentadas.</li>
                <li>No suponer que en las pruebas no se van a cometer errores.</li>
                <li>Cuantas más pruebas se realicen, mayor es la probabilidad de encontrar errores y, una vez solucionados, tendremos una capacidad mayor de poder perfeccionar nuestro sistema.</li>
            </ul>
            <p>El flujo del proceso a la hora de probar el software:</p>
            <ul>
                <li>1. Primero <b>generamos un plan de pruebas</b> a partir de la documentación del proyecto y de la documentación del software que debamos probar.</li>
                <li>2. Después se <b>diseñan las pruebas:</b> qué técnicas vamos a utilizar.</li>
                <li>3. <b>Ejecución de las pruebas.</b></li>
                <li>4. <b>Evaluación:</b> identificación de posibles errores.</li>
                <li>5. <b>Depuración:</b> localizar y corregir errores. Testar de nuevo tras encontrarse un error para verificar que se ha corregido.</li>
                <li>6. <b>Análisis de errores:</b> analizar la fiabilidad del software y mejorar los procesos de desarrollo.</li>
            </ul>
            <p>Para la realización del diseño de prueba se usan dos técnicas: <b>prueba de caja blanca y prueba de caja negra</b>. La primera valida la estructura interna del sistema, y la segunda, los requisitos funcionales sin observar el funcionamiento interno del programa.</p>
            <h4 class="apartado">1.5.5. Documentación</h4>
            <p>Cada etapa tiene que quedar documentada, necesitaremos reunir los documentos generados y hacer una clasificación según el nivel técnico.</p>
            <ul>
                <li>Deben actuar como medio de comunicación para que los miembros del equipo se puedan comunicar entre sí.</li>
                <li>Deben ser un almacén de información del sistema para poder ser utilizado por personal de mantenimiento.</li>
                <li>Proporcionan información para facilitar la planificación de gestión del presupuesto y programar el proceso de desarrollo de software.</li>
                <li>Algunos documentos deben especificar al usuario cómo debe usar y administrar el sistema.</li>
            </ul>
            <p>La documentación se puede dividir:</p>
            <ul>
                <li><b>Documentación de proceso:</b> En estos documentos se registra el proceso de desarrollo y mantenimiento. Así, se incluyen planes, estimaciones y horarios que se usan para predecir y controlar el proceso de software.</li>
                <li><b>Documentación del producto:</b> Este documento describe el producto que está siendo desarrollado e incluye la documentación del sistema y la documentación del usuario.</li>
            </ul>
            <p>La documentación se usará una vez que el sistema ya esté funcionando.</p>
            <h4 class="apartado">Documentación del usuario</h4>pág 55


            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subSeis">1.6. - Metodologías ágiles</h3>
          
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subSiete">1.7. - Proceso de obtención de código a partir del código fuente. Herramientas implicadas</h3>
          
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
        </div><!-- Fin contenedorApuntes -->
        <footer class="pieApuntes"><div>- SapheryDesings -</div></footer>
    </body>
</html>