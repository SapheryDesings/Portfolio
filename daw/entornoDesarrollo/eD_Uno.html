<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../css/clases.css">
  <link rel="stylesheet" href="../../css/mediaQ.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Smooch&family=Titan+One&display=swap" rel="stylesheet">
  <title>Entorno de Desarrollo</title>
</head>
    <body>
        <header>
            <div class="navtop">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html">Entorno de Desarrollo</a>
                <a href="../../index.html">Principal</a>
            </div>
        </header>
        <div class="contenedorApuntes">
            <h2 class="tituloTema" id="subUno">Tema 1. - Desarrollo de software</h2>
            
            <!--*********************************************************************-->
            <h3 class="subTitulo">El software del ordenador</h3>
            <p>La parte física, que llamamos <b>hardware</b> y que está compuesta por elementos físicos como el teclado, el ratón, el monitor, los discos duros o la placa base.</p>
            <p>El ordenador posee otra parte lógica llamada <b>software</b>, encargada de dar instrucciones al hardware y hacer funcionar la computadora.</p>
            <p>Podemos dividir el fostware en dos: según las tareas que realiza y según su método de distribución.</p>

            <h4 class="apartado">1.1.1. Software basado en el tipo de trabajo que realizan</h4>
            <ul>
                <li><b>Software de sistema:</b> es el que hace que el hardware funciones.</li>
                <li><b>Software de aplicación:</b> son los programas que realizan tareas específicas.</li>
                <li><b>Software de programación o desarrollo:</b> herramientas necesarias para escribir los programas informáticos y para hacer uso de distintos lenguajes de programación.</li>
            </ul>

            <h4 class="apartado">1.1.2. Software basado en el método de distribución</h4>
            <ul>
                <li><b>Shareware:</b> puede evaluar de forma gratuita el producto, pero con limitaciones.</li>
                <li><b>Freeware:</b> de forma gratuita, pero que mantiene los derechos de autor.</li>
                <li><b>Adware:</b> se ofrece publicidad incrustada, incluso durante la instalación de este.</li>
            </ul>
          
            <h4 class="apartado">1.1.3. Licencias de software. Software libre y propietario</h4>
            <p>Una <b>licencia</b> es un contrato entre el desarrollador de un software y el usuario final. <br> Existen dos tipos de licencias:</p>
            <ul>
                <li><b>Software libre:</b> el autor concede libertades al usuario:
                    <ul>
                        <li>Libertad para usar el programa con cualquier fin.</li>
                        <li>Libertad para saber cómo funciona el programa y adaptar el código a nuestras propias necesidades.</li>
                        <li>Libertad para poder compartir copias con otros usuarios.</li>
                        <li>Libertad para poder mejorar el programa y publicar las modificaciones realizadas.</li>
                    </ul>
                </li>
                <p>"Libre" no significa que sea gratis, es un concepto de libertad, no de precio.</p>
                <li><b>Software propietario:</b> no nos permitirá acceder al código fuente del programa, nos prohibirá la redistribución, la reprogramación, la copia o el uso simultáneo en varios equipos.</li>
            </ul>
            <p>La licencia que más se usa en el software libre es la licencia <b>GPL</b>, que nos dejará usar y cambiar el programa, con el único requisito de que se hagan públicas las modificaciones realizadas.</p>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subDos">1.2. - Concepto de programa informático</h3>
            <p>Un <b>programa informático</b> es un fragmento de software formado por una secuencia de instrucciones y procesos construidos con el fin de cumplir un objetivo concreto. Están escritos utilizando lenguajes de programación y deben ser traducidos al lenguaje máquina.</p>
            <h4 class="apartado">1.2.1. Programa y componentes del sistema informático</h4>
            <p>La arquitectura de nuestra CPU está basado en la arquitectura de <b>Von Neumann</b>.</p>
            <p>Tenemos otra estructura que es la llamada <b>Harvard</b>. La característica fundamental es eque tanto la memoria RAM como la memoria de instrucciones no comparten características comunes.</p>
            <p>La unidad de control UC es el centro de la arquitectura y conecta con la unidad aritmético-lógica UAL, los dispositivos de entrada y salida y con ambar memorias mencionadas anteriormente.</p>
            <p>En la arquitectura de Von Neumann, puede estar leyedendo o bien escribir pero ambos no pueden ocurrir a la vez.</p>
            <p>En la arquitectura Harvard, puede tanto leer una instrucción como realizar un acceso de memoria de datos.</p>
            <ul>
                <li><b>La unidad de control UC:</b> se encarga de interpretar y ejecutar las instrucciones que se almacenan en la memoria principal y, genera las señales de control necesarias para ejecutarlas.</li>
                <li><b>La unidad aritmético-lógica UAL:</b> es la que recibe los datos y ejecuta operaciones de cálculo y comparaciones, además de tomar decisiones lógicas (si son verdaderas o falsas), pero siempre supervisadas por la unidad de control.</li>
                <li><b>Los registros:</b> son aquellos que almacenan la información temporal. Es el almacenamiento interno de la CPU.</li>
            </ul>
            <p>Diferentes registros que posee la UC:</p>
            <ul>
                <li><b>Contador de programa CP:</b> contendrá la dirección de la siguiente instrucción para realizar. Su valor será actualizado por la CPU después de capturar una instrucción.</li>
                <li><b>Registro de instrucción RI:</b> es el que contiene el código de la instrucción, se analiza dicho código. Consta de dos partes: el código de la operación y la dirección de memoria en la que opera.</li>
                <li><b>Registro de dirección de memoria RDM:</b> tiene asignada una dirección correspondiente a una posición de memoria que va a almacenar la información mediante el bus de direcciones.</li>
                <li><b>Registro de intercambio de memoria RIM:</b> recibe o envía, según si es una operación de lectura o escritura, la información o dato contenido en el la posición apuntada por el RDM.</li>
                <li><b>Decodificador de instrucción DI:</b> extrae y analiza el código de la instrucción contenida en el RI.</li>
                <li><b>El reloj:</b> marca el ritmo del DI y nos proporciona unos impulsos eléctricos con intervalos constantes a la vez que marca los tiempos para ejecutar las instrucciones.</li>
                <li><b>El secuenciador:</b> son órdenes que se sincronizan con el reloj para que ejecuten correctamente y de forma ordenada la instrucción.</li>
            </ul>
            <p>Cuando ejecutamos una instrucción podemos distinguir dos fases:</p>
            <ul>
                <li><b>1. Fase de búsqueda:</b> se localiza la instrucción en la memoria principal y se envía a la unidad de control para poder procesarla.</li>
                <li><b>2. Fase de ejecución:</b> se ejecutan las acciones de las instrucciones.</li>
            </ul>
            <p>Para que podamos realizar operaciones de lectura y escritura en una celda de memoria, se utilizan el RDM, el RIM y el DI. El decodificador de instrucción es el encargado de conectar la celda RDM con el registro de intercambio RIM, el cual posibilita que la trasferencia de datos se realice en un sentido u otro según sea de lectura o escritura.</p>
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subTres">1.3. - Código fuente, código objeto y código ejecutable. Máquinas virtuales</h3>
            <h4 class="apartado">1.3.1. Tipo de código</h4>
            <p>Cuando escribamos un código, pasa por distintos estados:</p>
            <ul>
                <li><b>Código fuente:</b> es el código realizado por los programadores, en un lenguaje de alto nivel y para escribirlo se parte de, diagramas de clases. No se puede ejecutar directamente en el ordenador.</li>
                <li><b>Código objeto:</b> es el código que se crea tras realizar la compilación, no es entendido ni por el ordenador ni por nosotros. Representación intermedia de bajo nivel.</li>
                <li><b>Código ejecutable:</b> se obtiene tras unir el código objeto con varias librerías para que así pueda ser ejecutado por el ordenador.</li>
            </ul>
            <h4 class="apartado">1.3.2. Compilación</h4>
            <p>Es el proceso a través del cual se convierte un programa en lenguaje máquina a partir de otro programa de computadora escrito en otro lenguaje. Se realiza a través de dos programas: el compilador y el enlazador. Si en el <b>compilador</b> se detecta algún tipo de error no se generará el código objeto y tendremos que modificar el código fuente.</p>
            <ul>
                <li><b>Análisis léxico:</b> se lee el código obteniendo unidades de caracterres llamados tokens.</li>
                <li><b>Análisis sintáctico:</b> recibe el código fuente en forma de tokens y ejecuta el análisis para determinar la estructura del programa, se comprueba si cumplen las reglas sintácticas.</li>
                <li><b>Análisis semántico:</b> revisa que las declaraciones sean correctas, los tipos de todas las expresiones, si las operaciones se pueden realizar.</li>
                <li><b>Generación de código intermedio:</b> después de analizarlo todo, se crea una representación similar al código fuente para facilitar la tarea de traducir al código objeto.</li>
                <li><b>Optimización de código:</b> se mejora el código intermedio anterior para que sea más fácil y rápido a la hora de interpretarlo la máquina.</li>
                <li><b>Geración de código:</b> se genera el código objeto.</li>
            </ul>
            <p>El <b>enlazador</b> insertará en el código objeto las librerías necesarias para que se pueda producir un programa ejecutable. Si se hace referencia a otros ficheros que contengan las librerías especificadas en el código objeto, se combina con dicho código y se crea el fichero ejecutable.</p>
            <h4 class="apartado">1.3.3. Máquinas virtuales</h4>
            <p>Una máquina virtual es un tipo de software capaz de ejecutar programas como si fuese una máquina real.</p>
            <ul>
                <li><b>De sistema:</b> permiten virtualizar máquinas con distintos sistemas operativos en cada una.</li>
                <li><b>De proceso:</b> Se ejecutan como un proceso normal dentro de un sistema operativo y solo soportan un proceso. El objetivo es proporcionar un entorno de ejecución independiente del hardware y del sistema operativo y permitir que el programa sea ejecutado de la misma forma en cualquier plataforma.</li>
            </ul>
            <h4 class="apartado">La máquina virtual de Java</h4>
            <p>Los programas que se compilan en lenguaje Java son capaces de funcionar en cualquier plataforma. El código no lo ejecuta el procesador del ordenador sino la propia Máquina Virtual de Java. El funcionamiento es el siguiente:</p>
            <ul>
                <li>1. El código fuente estará escrito en archivos de texto planos con la extensión .java.</li>
                <li>2. El compilador <b>javac</b> generará uno o varios archivos, siempre que no se produzcan errores, y tendrán la extensión .class.</li>
                <li>3. Este fichero contendrá un lenguaje intermedio bytecode.</li>
                <li>4. La JVM coge y traduce mediante un compilador JIT el bytecode en código binario para que el procesador de nuestro ordenador sea capaz de reconocerlo.</li>
                <li>5. Los ficheros .class podrán ser ejecutados en múltiples plataformas.</li>
            </ul>
            <p>La máquina virtual de Java contiene las siguientes tareas:</p>
            <ul>
                <li>Carga y almacenamiento de datos.</li>
                <li>Excepciones (errores en tiempo de ejecución).</li>
                <li>Operaciones aritméticas.</li>
                <li>Conversiones de tipos de datos.</li>
                <li>Llamadas a métodos y devolución de datos.</li>
                <li>Creación y manejo de objetos.</li>
            </ul>
            <p>Las desventajas, puede ser que son más lentos que los ya compilados, debido a la capa intermedia.</p>
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subCuatro">1.4. - Tipos de lenguajes de programación. Clasificación y características de los lenguajes más difundidos</h3>
            <p>Lenguaje de programación hace referencia al conjunto de caracteres, reglas y acciones combinadas y consecutivas que un equipo debe ejecutar. Constará de los siguientes elementos:</p>
            <ul>
                <li><b>Alfabeto o vocabulario:</b> conjunto de símbolos permitidos.</li>
                <li><b>Sintaxis:</b> reglas para realizar correctamente construcciones con los símbolos.</li>
                <li><b>Semántica:</b> reglas que determinan el significado de contrucción del lenguaje.</li>
            </ul>
            <h4 class="apartado">1.4.1. Clasificación y características</h4>
            <p>Podemos clasificar los lenguajes de programación basándonos en los siguientes criterios:</p>
            <table>
                <tbody>
                    <tr>
                        <th>Según su nivel de abstracción</th>
                        <td>Lenguajes de bajo nivel. <br>
                        Lenguajes de nivel medio. <br> 
                        Lenguajes de alto nivel.
                        </td>
                    </tr>
                    <tr>
                        <th>Según la forma de ejecución:</th>
                        <td>Lenguajes compilados. <br> 
                        Lenguajes interpretados. <br>
                        </td>
                    </tr>
                    <th>Según el paradigma de programación:</th>
                    <td>Lenguajes imperativos. <br>
                        Lenguajes funcionales. <br>
                        Lenguajes lógicos. <br>
                        Lenguajes estructurados. <br>
                        Lenguajes orientados a objetos. <br>
                    </td>
                </tbody>
            </table>
            <h4 class="apartado">Según su nivel de abstracción</h4>
            <p><b>Lenguajes de bajo nivel:</b> el de más bajo nivel es <b>el lenguaje máquina.</b> Utiliza el lenguaje binario y los programas son específicos para cada procesador. Al lenguaje máquina le sigue el <b>lenguaje ensamblador</b>. Complicado de aprender y es específico para cada procesador. Este lenguaje tiene que ser traducido al lenguaje máquina. Se utilizan nombres mnemotécnicos y las instrucciones trabajan directamente con registros de memoria física.</p>
            <ul>
                <li>Los registros extendidos de 32 bits, como EAX (registro acumulador), EBX (registro de índice base), ECX (registro de conteo) o EDX (registro de datos).</li>
                <li>Estos registros se dividen en registros de menor tamaño, como AX, BX, CX Y DX, de 16 bits, y estos, a su vez, en otros de 8 bits, como AH, AL, BH, BL, CH, CL, DH o DL.
                    <ul>
                        <li><b>EAX:</b> el acumulador se utiliza para instrucciones tales como multiplicación o división.</li>
                        <li><b>EBX:</b> guarda la dirección de desplazamiento de una posición en el sistema de memoria.</li>
                        <li><b>ECX:</b> es un registro de propósito general que guara la cuenta de varias instrucciones. Realiza funciones de contador.</li>
                        <li><b>EDX:</b> es un registro de propósito general que almacena datos de, por ejemplo, aplicaciones aritméticas como el divisor antes de hacer una división.</li>
                    </ul> <br>
                    Podemos realizar operaciones con estos registros.
                </li>
            </ul>
            <p><b>Lenguajes de nivel medio:</b> poseen características de ambos tipos de nivel, tanto del nivel bajo como del alto, y se suele usar para la creación de sitemas operativos.</p>
            <p><b>Lenguajes de alto nivel:</b> es más fácil a la hora de aprender, utilizan nuestro lenguaje natural. Para poder ejecutar lo que escribamos, necesitaremos un compilador para que traduzca al lenguaje máquina las intrucciones. Es independiente de la máquina, no depende del hardware.</p>
            <h4 class="apartado">Según la forma de ejecución</h4>
            <p><b>Lenguajes compilados:</b> al programar en alto nivel, hay que traducir ese lenguaje a lenguaje máquina a través de compiladores. Devolverán errores si el lenguaje fuente está mal escrito y lo ejecutarán si el lenguaje destino es ejecutable por la máquina.</p>
            <p><b>Lenguajes interpretados:</b> otra variante para traducir programas de alto nivel. Cuando ejecutamos una instrucción, se debe interpretar y traducir al lenguaje máquina. El compilador es, más rápido que un intérprete, al usar el intérprete evitaremos tener que compilar cada vez que hagamos alguna modificación. Java usa tanto la compilación como la interpretación, puede compilarse primero en un formato intermedio, llamado bytecodes, para que luego una máquina virtual lo interprete.</p>
            <h4 class="apartado">Según el paradigma de programación</h4>
            <p>El paradigma de programación nos detalla las reglas, patrones y los estilos de programación que usan los lenguajes. Pueden usar más de un paradigma.</p>
            <p><b>Lenguajes imperativos:</b> los primeros lenguajes imperativos que se usaron fueron el lenguaje máquina y el lenguaje ensamblador. Consisten en una serie de sentencias que establecen cómo debe manipularse la información presente en cada memoria o cómo se debe enviar o recibir la información. Las estructuras de control podemos establecer el orden en que se ejecutan y modificar el flujo del programa según los resultados de las acciones. Casi todos los <b>lenguajes de desarrollo de software comercial</b> son imperativos.</p>
            <ul>
                <li><b>Programación estructurada.</b></li>
                <li><b>Programación modular.</b></li>
                <li><b>Programación orientada a objetos.</b></li>
            </ul>
            <p><b>Lenguajes funcionales:</b> están basados en el concepto de función y estarán formados por definiciones de funciones junto con sus argumentos. Entre sus características destaca que no existe la operación de asignación. Las variables almacenan definiciones a expresiones. El resultado de un cálculo es la entrada del siguiente, y así sucesivamente hasta que se consigue el valor deseado. Apenas se usar para el software comercial.</p>
            <p><b>Lenguajes lógicos:</b> están basados en el concepto de razonamiento, deductivo o inductivo. A partir de una base de datos consistente en un conjunto de entidades, propiedades de esas entidades o relaciones entre entidades, el sistema es capaz de hacer <b>razonamientos</b>. Los programas escritos en este lenguaje suelen tener forma de una <b>base de datos</b>, está formada por declaraciones lógicas, que son ciertas o falsas, que podremos consultar. La ejecución será en forma de consultas hacia esa base de datos. El lenguaje lógico más importante es Prolog.</p>
            <p><b>Lenguajes estructurados:</b> utilizan las tres construcciones lógicas y resultan fáciles de leer. El inconveniente es el código, que está centrado en un solo bloque, lo que dificulta el proceso de hallar el problema. Nos estamos refiriendo a programas creados a través de modulos, pequeñas partes más manejables que unidas entre sí, hacen que el programa funcione. Cada módulo poseen una entrada y una salida y deben estar perfectamente comunicados, aunque cada uno de llos trabaja de forma independiente.</p>
            <p>La evolución a esta programación mediante módulos se le denomina <b>programación modular</b> y posee las siguientes ventajas:</p>
            <ul>
                <li>Al dividir el programa en módulos, varios programadores podrán trabajar a la vez en cada uno de ellos.</li>
                <li>Estos módulos pueden usarse para otras aplicaciones.</li>
                <li>Si surge algún problema será más fácil y menos costoso detectarlo y abordarlo, ya qe se puede resolver de forma aislada.</li>
            </ul>
            <p><b>Lenguajes orientados a objetos:</b> estarán definidos por un conjunto de objetos en vez de por módulos.</p>
            <p>Estos objetos están formados por una estructura de datos y por una colección de métodos que enterpretan esos datos. Los datos que se encuentran dentro de los objetos son sus <b>atributos</b>, y las operaciones que se realizan sobre los objetos cambian el valor de uno o más atributos.</p>
            <p>La comunicación entre objetos se realiza a través de mensajes.</p>
            <p>Una clase es una plantilla para creación de objetos. Al crear un objeto, se ha de especificar a qué clase pertenece para que el compilador sepa qué características posee.</p>
            <p>Las ventajas, destacar la facilidad para reutilizar el código, el trabajo en equipo o el mantenimiento del software.</p>
            <p>Una desventaja es que el concepto de un programador puede ser distinto a otros.</p>
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subCinco">1.5. - Fases del desarrollo de una aplicación: análisis, diseño, codificación, pruebas, documentación, mantenimiento y explotación</h3>
            <p>Cuando queramos realizar un proyecto de software, antes debemos crear un ciclo de vida en el que examinemos las características para eligir un modelo de desarrollo u otro.</p>
            <h4 class="apartado">Modelo en cascada</h4>
            <p>Las etapas para el desarrollo de software tienen un orden, para empezar una etapa, es necesario finalizar la etapa anterior. Después de cada etapa se realiza una revisión para comprobar si se puede pasar a la siguiente.</p>
            <p>Permite hacer iteraciones, es decir, si se tiene que volver a una de las etapas anteriores, hay que recorrer de nuevo el resto de etapas.</p>
            <p>Tiene distintas variantes, una de las más utilizadas es el <b>modelo en cascada con retroalimentación</b>, en las etapas se detectan fallos, entonces, será necesario retornar a la etapa anterior para realizar los ajustes pertinentes. Se le conoce como retroalimentación.</p>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Fácil de comprender, planificar y seguir.</td>
                        <td>La necesidad de tener todos los requisitos definidos desde el principio.</td>
                    </tr>
                    <tr>
                        <td>La calidad del producto resultante es alta.</td>
                        <td>Es difícil volver atrás si se comenten errores en una etapa (es un modelo inflexible)</td>
                    </tr>
                    <tr>
                        <td>Los recursos que se necesitan son mínimos.</td>
                        <td>El producto no está disponible para su uso hasta que no está completamente terminado.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda cuando:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">El proyecto es similar a alguno que ya se haya realizado con éxito anteriormente.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Los requisitos son estables y están bien comprendidos.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Los clientes no necesitan versiones intermedias.</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Modelo iterativo incremental</h4>
            <p>Basado en varios ciclos en cascada realimentados aplicados repetidamente.</p>
            <p>Entrega el software en partes pequeñas, pero utilizables, llamadas incrementos o prototipos.</p>
            <p>Cada incremento se construye sobre aquel que ya ha sido entregado.</p>
            <p>Al desarrollar el software de manera incremental, resulta más barato y fácil realizar cambios en el software conforme este se va desarrollando.</p>
            <p>Cada incremento del aplicativo incorpora algunas de las funciones que necesita el cliente. Esto significa que el cliente puede evaluar el desarrollo del sistema en una etapa temprana.</p>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>No necesitan conocer todo los requisitos. Se reduce, por tanto, el coste de adaptar los requerimientos cambiantes del cliente.</td>
                        <td>Es difícil estimar el esfuerzo y el coste final necesarios.</td>
                    </tr>
                    <tr>
                        <td>Permite la entrega temprana al cliente de partes operativas del software.</td>
                        <td>Se tiene el riesgo de no acabar nunca.</td>
                    </tr>
                    <tr>
                        <td>Las entregas facilitan la realimentación de los próximos entregables.</td>
                        <td>No es recomendable para desarrollo de sistemas de tiempo real, de alto nivel de seguridad, de procesamiento distribuido y/o de alto índice de riesgos.</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>La incorporación de muchos cambios hace que el software se vuelva inestable.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda cuando:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">Los requisitos o el diseño no están completamente definidos y es posible que haya grandes cambios.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Se están probando o introduciendo nuevas tecnologías.</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Modelo en espiral</h4>
            <p>Combina el modelo en cascada con el modelo iterativo de construcción de prototipos. Se representa como una espiral donde en cada ciclo se desarrolla una parte de este. Cada ciclo está formado por cuatro fases y produce una versión incremental del software con respecto al ciclo anterior. Se parece al modelo iterativo incremental, con la diferencia de que en cada ciclo se tiene en cuenta el análisis de riesgos. Para cada ciclo, los desarrolladores siguen estas fases:</p>
            <ul>
                <li><b>1. Determinar objetivos:</b> cada ciclo comienza con la identificación de los objetivos, las alternativas para alcanzar los objetivos y  las restricciones impuestas a la aplicación de las alternativas.</li>
                <li><b>2. Análisis del riesgo:</b> hay que evaluar las alternativas en relación con los objetivos y limitaciones. En este proceso se identifican los riesgos involucrados y la manera de resolverlos. Se aconseja realizar un análisis minucioso para reducir los riesgos. Utiliza la construcción de prototipos como mecanismo de reducción de riesgos.</li>
                <li><b>3. Desarrollar y probar:</b> desarrollar la solución al problema en este ciclo y verificar que es aceptable.</li>
                <li><b>4. Planificación:</b> revisar y evaluar todo lo que se ha hecho y, con ello, decidir si se continúa; entonces hay que planificar las fases del ciclo siguiente.</li>
            </ul>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>No requiere una definición completa de los requisitos para empezar a funcionar.</td>
                        <td>Es difícil evaluar los riesgos.</td>
                    </tr>
                    <tr>
                        <td>Análisis del riesgo en todas las etapas.</td>
                        <td>El costo del proyecto aumenta a medida que la espiral pasa por sucesivas iteraciones.</td>
                    </tr>
                    <tr>
                        <td>Reduce riesgos del proyecto.</td>
                        <td>El éxito del proyecto depende en gran medida de la fase de análisis de riesgos.</td>
                    </tr>
                    <tr>
                        <td>Aumento de la productividad.</td>
                        <td>Es difícil hacer ver al cliente que este enfoque evolutivo es controlable.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda para:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">Proyectos de gran tamaño y que necesitan constantes cambios.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Proyectos donde sea importante el factor riesgo.</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">Modelo en V</h4>
            <p>Es un proceso que representa la secuencia de pasos en el desarrollo del ciclo de vida de un proyecto. En él se describen las actividades y resultados que deben producirse durante el desarrollo del producto. El <b>lado izquierdo</b> representa la descomposición de las necesidades y la creación de las especificaciónes. El <b>lado derecho</b> representa la integración de las piezas y su verificación.</p>
            <table>
                <thead>
                    <tr>
                        <th>Ventajas</th>
                        <th>Inconvenientes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Facilita la localización de fallos.</td>
                        <td>Las pruebas pueden llegar a ser costosas.</td>
                    </tr>
                    <tr>
                        <td>Modelo muy sencillo.</td>
                        <td>El cliente debe tener paciencia hasta el producto final.</td>
                    </tr>
                    <tr>
                        <td>El cliente está involucrado en las pruebas.</td>
                        <td>Pueden no estar bien definidos los requisistos del cliente.</td>
                    </tr>
                    <tr>
                        <td colspan="2"><b>Se recomienda para:</b></td>
                    </tr>
                    <tr>
                        <td colspan="2">Ser aplicado en sistemas sencillos pero de confiabilidad alta (transacciones en bases de datos).</td>
                    </tr>
                </tbody>
            </table>
            <h4 class="apartado">1.5.1. Análisis</h4>
            <p>La parte más importante es entender qué se quiere realizar y analizar las posibilidades alternativas y soluciones. Es <b>fundamental</b> analizar los requisitos que el cliente ha solicitado.</p>
            <p>El análisis consiste en la especificación de las características operativas del software, indica cuál es la interfaz que ha de desarrollarse y marca las restricciones de este.</p>
            <p>Aunque pueda parecerlo, no es una tarea fácil, ya que a menudo el cliente es poco claro y durante el desarrollo pueden surgir nuevos requerimientos. Para la obtención d estos requisitos, se usarán distintas técnicas:</p>
            <ul>
                <li><b>Entrevistas:</b> En un ambiente más relajado, el cliente tiende a expresarse con más claridad.</li>
                <li><b>Desarrollo conjunto de aplicaciones:</b> entrevista de dinámica de grupo en la que cada integrante aporta su conocimiento.</li>
                <li><b>Planificación conjunta de requisitos:</b> el objetivo es involucrar a la dirección para obtener mejores resultados en el menor tiempo. La diferencia es la participación del nivel más alto de la organización en la visión general del negocio.</li>
                <li><b>Brainstorming:</b> se intentan crear ideas desde distintos puntos de vista. Idónea para el comienzo del proyecto.</li>
                <li><b>Prototipos:</b> versión inicial del sistema en el que se puede ver el problema y sus posibles soluciones. Se puede desechar o usar para añadir más cosas.</li>
                <li><b>Casos de uso:</b> son una ayuda para definir lo que existe fuera del sistema y lo que debe realizar el sistema son fundamentales en la ingeniería de requisistos.</li>
            </ul>
            <p>Requisitos:</p>
            <ul>
                <li><b>Requisitos funcionales:</b> nos describen al detalle la función que realiza el sistema, la reacción ante determinadas entradas y cómo se comporta en distintas situaciones.</li>
                <li><b>Requisitos no funcionales:</b> son limitaciones sobre la funcionalidad que ofrece el sistema. Se refieren a las propiedades emergentes del sistema, como la fiabilidad o la capacidad de almacenamiento. Incluyen restricciones impuestas por el estándar del aplicativo.</li>
            </ul>
            <p>Representar estos requisitos, podemos:</p>
            <p><b>Modelo basado en el escenario:</b> se basa en el punto de vista de los actores del sistema. Lo podemos representar con los casos de uso o las historias de usuario.</p>
            <p><b>Modelo de datos:</b> muestra el entorno y la información del problema. Lo podemos representar con el diccionario de datos.</p>
            <ul>
                <li><b>Diccionario de datos:</b> descripción detallada de los datos utilizados por el sistema que gráficamente están representado por los flujos de datos y almacenes presentes sobre el conjunto de DFD. <br> En esta primera fase de análisis, todo lo que se realice quede plasmado en el documento Especificación de Requisitos de Software. Debe ser completo, sin ambigüedades, sencillo de usar a la hora de verificarlo, modificarlo o de identificar el origen y las consecuencias de los requisitos. Servirá para la siguiente fase.</li>
                <li><b>Diagrama entidad/relación:</b> se usa para representar datos y sus relaciones. Representa los datos que se introducen, almacenan y transforman en el sistema.</li>
            </ul>
            <p><b>Modelos orientados al flujo:</b> representan los elementos funcionales del sistema de tal forma que reflejan cómo se transforman los datos a medida que avanzan dentro del aplicativo.</p>
            <ul>
                <li><b>Diagramas de flujo de datos:</b> nos va a representar el flujo de datos entre procesos, entidades externas y almacenes del sistema:</li>
                <ul>
                    <li><b>Procesos:</b> burbujas ovaladas o circulares.</li>
                    <li><b>Entidades externas:</b> rectángulos.</li>
                    <li><b>Almacenes:</b> dos líneas horizontales y paralelas.</li>
                    <li><b>Flujo de datos:</b> flechas.</li>
                </ul>
                <li><b>Diagramas de flujo de control:</b> en vez de flujo de datos muestra el flujo de control. Producen información de control y procesan información con mucha atención al tiempo y al rendimiento.</li>
                <li><b>Diagramas de transición de estados:</b> representa el comportamiento del sistema dependiente del tiempo.</li>
            </ul>
            <h4 class="apartado">1.5.2. Diseño</h4>
            pág 37
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subSeis">1.6. - Metodologías ágiles</h3>
          
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
            <h3 class="subTitulo" id="subSiete">1.7. - Proceso de obtención de código a partir del código fuente. Herramientas implicadas</h3>
          
            <div class="menuOpcional">
                <a href="../entornoDesarrollo/indice_entornoDesarrollo.html"><div class="botonO">Índice</div></a>
                <a href="../../index.html"><div class="botonO">Principal</div></a>
                <a href="#subUno"><div class="botonO">Arriba</div></a>
            </div>
            <!--*********************************************************************-->
        </div><!-- Fin contenedorApuntes -->
        <footer class="pieApuntes"><div>- SapheryDesings -</div></footer>
    </body>
</html>